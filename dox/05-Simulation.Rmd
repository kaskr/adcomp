```{r echo=FALSE, eval=TRUE, results='hide'}
source("layout/utils.R")
```

Simulation {#Simulation}
==========

When building models in TMB it is generally recommended to test the
implementation on simulated data. Obviously, data can be simulated
from R and passed to the C++ template. In practice this amounts to
implementing the model twice and is thus a strong way to validate the
implementation of the model.  However, with increased model complexity
it becomes inconvenient to maintain two separate
implementations. Therefore, TMB allows the the user to write the
simulation code as an integrated part of the C++ model template.


## Overview of simulation methods in TMB

### Standard generators

The TMB simulation routines use the same naming convention as the R
simulators. For instance `rnorm()` is used to simulate from a normal
distribution. However, the argument convention is slightly
different:

1. `rnorm(n, mu, sd)` draws `n` simulations from a normal
   distribution. Unlike R this works for **scalar parameters only**.
2. `rnorm(mu, sd)` is a TMB specific variant that works for
   **mixed scalar and vector input**. Output length follows the length of the
   longest input (no re-cycling) hence is consistent with `dnorm(mu, sd)`.

Currently the following simulators are implemented:

```{r, results='asis', echo=FALSE}
tmp <- unlist(lapply(dir("../TMB/inst/include", ".hpp$", full=TRUE), readLines))
tmp <- grep('^VECTORIZE._n', tmp, value=TRUE)
tmp <- sub(".*\\((.*)\\)","\\1",tmp)
tmp <- paste(paste0("`",tmp,"()`"), collapse=", ")
cat("> ", tmp)
```

### Generators for density objects

Objects from the density namespace have their own `simulate()`
method. Taking the multivariate normal distribution as example we have
the following ways to draw a simulation:

1. `MVNORM(Sigma).simulate()` returns a vector with a simulation from
   the multivariate normal distribution. The void argument version is
   only available when there is no ambiguity in the dimension of the
   output. In the `MVNORM` case the dimension of the output is known
   from the dimension of `Sigma`. In other cases e.g. `AR1(phi)` the
   dimension of the output is not known hence the void argument
   version is not available.
2. `MVNORM(Sigma).simulate(x)` pass `x` by reference and writes the
   simulation directly to `x` without returning anything. This version
   is available for *all* the classes because the dimension of the
   simulation can always be deduced from `x`.

### Controlling the random seed

All TMB simulation methods are based on R's random number
generator. It follows that the random seed can be controlled from R
the usual way using `set.seed` even though the simulation is performed
on the C++ side.

## Simulation blocks

Simulation functions can be called from anywhere in the C++
program. However, usually one should put the simulation code inside
specialized *simulation blocks* that allows the code to only be
executed when requested from R.

### A linear regression example

A complete example extending the example `r doxylink("linreg.cpp")`
with simulation code is:

```{r, echo=FALSE}
create_source("
#include <TMB.hpp>
template<class Type>
Type objective_function<Type>::operator() ()
{
  DATA_VECTOR(y);
  DATA_VECTOR(x);
  PARAMETER(a);
  PARAMETER(b);
  PARAMETER(sd);
  vector<Type> mu = a + b * x;
  Type nll = -sum(dnorm(y, mu, sd, true));
  SIMULATE {
    y = rnorm(mu, sd);  // Simulate response
    REPORT(y);          // Report the simulation
  }
  return nll;
}
", "linreg.cpp")
```

`r include_source("linreg.cpp")`

> The `SIMULATE` block marks the simulation and is not executed by default.

```{r, eval=TRUE, include=FALSE}
library(TMB)
compile("linreg.cpp")
dyn.load(dynlib("linreg"))
set.seed(123)
data <- list(y = rnorm(10) + 1:10, x=1:10)
parameters <- list(a=0, b=0, sd=1)
obj <- MakeADFun(data, parameters, DLL="linreg")
```

We compile the C++-file and the model object is constructed as usual:

```{r}
obj <- MakeADFun(data, parameters, DLL="linreg")
```

Now a simulation can be generated with

```{r}
set.seed(1) ## optional
obj$simulate()
```

This only includes the simulated response - not the rest of the
data. A complete dataset can be generated by:

```{r}
set.seed(1) ## optional - Note: same y as previous
obj$simulate(complete=TRUE)
```

Here we did not explicitely state the parameter values to use with the
simulation. The `simulate` method takes an additional argument `par`
that can be used for this.

> The default parameter values used for the simulation is
> `obj$env$last.par`.

### A simulation study

Simulating datasets from known parameters and re-estimationg those
parameters can be done generically by:

```{r}
sim <- replicate(50, {
  simdata <- obj$simulate(par=obj$par, complete=TRUE)
  obj2 <- MakeADFun(simdata, parameters, DLL="linreg", silent=TRUE)
  nlminb(obj2$par, obj2$fn, obj2$gr)$par
})
```

We reshape and plot the result:

```{r, fig=TRUE}
library(lattice)
df <- data.frame(estimate=as.vector(sim), parameter=names(obj$par)[row(sim)])
densityplot( ~ estimate | parameter, data=df, layout=c(3,1))
```

Compare with the true parameter values of the simulation:

```{r}
obj$par
```

### Advanced examples

The examples `r doxylink("sam.cpp")` and `r doxylink("ar1_4D.cpp")`
includes more advanced simulation code. The latter demonstrates how to
simulate from the density objects:

`r include_source("../tmb_examples/ar1_4D.cpp")`

In this example the 4D-array `eta` is passed to the simulator by
reference. Thereby the simulator knows the dimension of `eta` and can
fill `eta` with a simulation.

### Further notes

The above example only used one simulation block. In general there is
no limitation on the number of simulation blocks that can be used in a
model and simulation blocks can use temporaries calculated outside the
blocks (as demonstrated in the linear regression example). For clarity
reasons, it is often a good idea to add a simulation block after each
likelihood contribution. However, note that simulation blocks are in
general **not** commutative (unlike likelihood accumulation).  It is
therefore further recommended to add likelihood contributions of
random effects in the natural hierarchical order.
