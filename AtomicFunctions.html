<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: Atomic functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Atomic functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Custom functions and derivatives can be added to the TMB library. This may be necessary for the following reasons:</p>
<ul>
<li>Adaptive (e.g. iterative) algorithms cannot be represented by a fixed computational graph and thus cannot be directly differentiated using TMB. Algorithms that use parameter dependent if-else branching are examples of such functions.</li>
<li>Some functions have so many floating point operations that it is infeasible to expand the computational graph. Memory usage may be greatly reduced in such cases by collapsing the computational graph to a singe node with multiple inputs and outputs.</li>
</ul>
<h2>Reverse mode differentiation</h2>
<p>TMB uses CppAD as its engine for reverse mode derivatives. In order to add a new primitive function</p>
<p class="formulaDsp">
\[f: R^n \rightarrow R^m\]
</p>
<p>we must inform CppAD how to calculate derivatives of this function in reverse mode. That is, for any range space vector \(w \in R^m\) we must calculate the gradient of the function \(R^n \rightarrow R\) given by</p>
<p class="formulaDsp">
\[ x \rightarrow \text{sum}( f(x) \odot w ) \]
</p>
<p>where '$$' is pointwise multiplication.</p>
<h2>Example: Adding new primitive function with known derivatives</h2>
<p>As an example consider the <a href="https://en.wikipedia.org/wiki/Lambert_W_function">Lambert W function</a> defined implicitly by</p>
<p class="formulaDsp">
\[y = W(y e^y)\]
</p>
<p>Here, we only consider \(W\) as defined on the positive reals. It follows, by differentiating the above identity, that</p>
<p class="formulaDsp">
\[ W&#39;(x) = \frac{1}{ \exp\left(W(x)\right) \left(1 + W(x)\right) } \]
</p>
<p>When coding reverse-mode derivatives we can assume that the function value \(W(x)\) has already been computed during a forward pass. For efficiency reasons we should use this intermediate calculation rather than re-calculating \(W(x)\) in the reverse pass.</p>
<p>We'll assume that a plain C++ function (taking double types as input/output) is available to calculate \(W(x)\). It doesn't matter whether you have the source code of an implementation or just the header with linkage to an external library:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> LambertW(<span class="keywordtype">double</span> x);</div></div><!-- fragment --><p>The macro <code><a class="el" href="group__macros.html#ga456208023a75e7f193b5af7eb0090781" title="Construct atomic vector function based on known derivatives. ">TMB_ATOMIC_VECTOR_FUNCTION()</a></code> is used to declare our new primitive Lambert \(W\) function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#ga456208023a75e7f193b5af7eb0090781">TMB_ATOMIC_VECTOR_FUNCTION</a>(</div><div class="line">    <span class="comment">// ATOMIC_NAME</span></div><div class="line">    LambertW</div><div class="line">    ,</div><div class="line">    <span class="comment">// OUTPUT_DIM</span></div><div class="line">    1,</div><div class="line">    <span class="comment">// ATOMIC_DOUBLE</span></div><div class="line">    ty[0] = LambertW(tx[0]); <span class="comment">// Call the &#39;double&#39; version</span></div><div class="line">    ,</div><div class="line">    <span class="comment">// ATOMIC_REVERSE</span></div><div class="line">    Type W  = ty[0];                    <span class="comment">// Function value from forward pass</span></div><div class="line">    Type DW = 1. / (exp(W) * (1. + W)); <span class="comment">// Derivative</span></div><div class="line">    px[0] = DW * py[0];                 <span class="comment">// Reverse mode chain rule</span></div><div class="line">)</div></div><!-- fragment --><p>Let's explain in detail what is going on. The macro takes four arguments:</p>
<ol type="1">
<li><code>ATOMIC_NAME</code>: Name of new primitive function taking <code>CppAD::vector</code> as input and output.</li>
<li><code>OUTPUT_DIM</code>: Dimension of the <code>CppAD::vector</code> which is the function output.</li>
<li><code>ATOMIC_DOUBLE</code>: Specifies how to evaluate the primitive function for the ordinary double type. <code>tx</code> denotes the input vector and <code>ty</code> the output vector of the function \(f: R^n \rightarrow R^m\). In this case both have dimension one.</li>
<li><code>ATOMIC_REVERSE</code>: How to calculate the reverse mode derivatives for a general <code>Type</code>. Again <code>tx</code> and <code>ty</code> denote function input and output but now <code>ty</code> has been computed and is available as an intermediate value. The vectors <code>px</code> and <code>py</code> denote partial derivatives of the end result with respect to \(x\) and \(y\) respectively. <code>py</code> is given and we must calculate <code>px</code> using the chain rule. This first order derivative rule is automatically expanded up to higher orders required when using TMB's random effects calculations.</li>
</ol>
<p>To make the function work like other TMB functions it is convenient to define scalar and a vectorized versions that call the atomic function:</p>
<div class="fragment"><div class="line"><span class="comment">// Scalar version</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line">Type LambertW(Type x){</div><div class="line">  CppAD::vector&lt;Type&gt; tx(1);</div><div class="line">  tx[0] = x;</div><div class="line">  <span class="keywordflow">return</span> LambertW(tx)[0];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Vectorized version</span></div><div class="line">VECTORIZE_1t(LambertW)</div></div><!-- fragment --><h3>Testing the primitive function</h3>
<p>Here is a complete example using Newton's method to calculate the Lambert \(W\) function (there are more sophisticated algorithms such as the one by <a href="https://doi.org/10.1016/j.cam.2012.11.021">Fukushima (2013)</a>, but that doesn't matter for this example):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TMB_8hpp.html">TMB.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Double version of Lambert W function</span></div><div class="line"><span class="keywordtype">double</span> LambertW(<span class="keywordtype">double</span> x) {</div><div class="line">  <span class="keywordtype">double</span> logx = log(x);</div><div class="line">  <span class="keywordtype">double</span> y = (logx &gt; 0 ? logx : 0);</div><div class="line">  <span class="keywordtype">int</span> niter = 100, i=0;</div><div class="line">  <span class="keywordflow">for</span> (; i &lt; niter; i++) {</div><div class="line">    <span class="keywordflow">if</span> ( fabs( logx - log(y) - y) &lt; 1e-9) <span class="keywordflow">break</span>;</div><div class="line">    y -= (y - exp(logx - y)) / (1 + y);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (i == niter) Rf_warning(<span class="stringliteral">&quot;W: failed convergence&quot;</span>);</div><div class="line">  <span class="keywordflow">return</span> y;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group__macros.html#ga456208023a75e7f193b5af7eb0090781">TMB_ATOMIC_VECTOR_FUNCTION</a>(</div><div class="line">    <span class="comment">// ATOMIC_NAME</span></div><div class="line">    LambertW</div><div class="line">    ,</div><div class="line">    <span class="comment">// OUTPUT_DIM</span></div><div class="line">    1,</div><div class="line">    <span class="comment">// ATOMIC_DOUBLE</span></div><div class="line">    ty[0] = LambertW(tx[0]); <span class="comment">// Call the &#39;double&#39; version</span></div><div class="line">    ,</div><div class="line">    <span class="comment">// ATOMIC_REVERSE</span></div><div class="line">    Type W  = ty[0];                    <span class="comment">// Function value from forward pass</span></div><div class="line">    Type DW = 1. / (exp(W) * (1. + W)); <span class="comment">// Derivative</span></div><div class="line">    px[0] = DW * py[0];                 <span class="comment">// Reverse mode chain rule</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Scalar version</span></div><div class="line">template&lt;class Type&gt;</div><div class="line">Type LambertW(Type x){</div><div class="line">  CppAD::vector&lt;Type&gt; tx(1);</div><div class="line">  tx[0] = x;</div><div class="line">  <span class="keywordflow">return</span> LambertW(tx)[0];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Vectorized version</span></div><div class="line"><a class="code" href="Vectorize_8hpp.html#a1055d4f2b2504316a2fb8c939c8c1ce4">VECTORIZE1_t</a>(LambertW)</div><div class="line"></div><div class="line">template&lt;class Type&gt;</div><div class="line">Type objective_function&lt;Type&gt;::operator() ()</div><div class="line">{</div><div class="line">  <a class="code" href="group__macros.html#ga6b8a70eeee38fe896e89e0a9c6bef84a">PARAMETER_VECTOR</a>(x);</div><div class="line">  Type f = LambertW(x).sum();</div><div class="line">  <span class="keywordflow">return</span> f;</div><div class="line">}</div></div><!-- fragment --><p>And from R</p>
<div class="fragment"><div class="line">compile(&quot;lambert.cpp&quot;)</div><div class="line">dyn.load(dynlib(&quot;lambert&quot;))</div></div><!-- fragment --><h4>Checking function value and derivatives</h4>
<p>Check definition of the function:</p>
<div class="fragment"><div class="line">obj &lt;- MakeADFun(data=list(), parameters=list(x=1), DLL=&quot;lambert&quot;)</div><div class="line">obj$fn(7 * exp(7))</div></div><!-- fragment --><div class="fragment"><div class="line">## [1] 7</div></div><!-- fragment --><p>Check derivatives using the <code>numDeriv</code> package:</p>
<div class="fragment"><div class="line">numDeriv::grad(obj$fn, 7)</div></div><!-- fragment --><div class="fragment"><div class="line">## [1] 0.08626538</div></div><!-- fragment --><div class="fragment"><div class="line">obj$gr(7)</div></div><!-- fragment --><div class="fragment"><div class="line">##            [,1]</div><div class="line">## [1,] 0.08626538</div></div><!-- fragment --><p>Also try second order derivatives:</p>
<div class="fragment"><div class="line">numDeriv::hessian(obj$fn, 7)</div></div><!-- fragment --><div class="fragment"><div class="line">##             [,1]</div><div class="line">## [1,] -0.01038959</div></div><!-- fragment --><div class="fragment"><div class="line">obj$he(7)</div></div><!-- fragment --><div class="fragment"><div class="line">##             [,1]</div><div class="line">## [1,] -0.01038969</div></div><!-- fragment --><h2>Other approaches</h2>
<p>For the Lambert \(W\) function we know how to calculate the derivatives. There are cases for which the derivatives are impossible (or difficult) to write down. If you're in this situation you may want to try using forward mode AD to help in defining an atomic function. A full worked out example is available here: <a class="el" href="adaptive_integration_8cpp-example.html">adaptive_integration.cpp</a>. Derivatives are calculated automatically and if-else branching is allowed. The main downside with this approach is that it is limited to functions with very few inputs.</p>
<p>Checkpointing is another useful technique. It is demonstrated in the example <a class="el" href="register_atomic_8cpp-example.html">register_atomic.cpp</a>. It does not work for adaptive algorithms but is otherwise automatic. It is useful to reduce AD memory usage in cases where the same sequence of operations is being applied many times. </p>
</div></div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
