<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>TMB (Template Model Builder) is an R package for fitting statistical latent variable models to data. It is strongly inspired by <a href="http://www.admb-project.org">ADMB</a>. Unlike most other R packages the model is formulated in C++. This provides great flexibility, but requires some familiarity with the C/C++ programming language.</p>
<ul>
<li>TMB can calculate first and second order derivatives of the likelihood function by <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">AD</a>, or any objective function written in C++.</li>
<li>The objective function (and its derivatives) can be called from R. Hence, parameter estimation via e.g. <code>nlminb()</code> is easy.</li>
<li>The user can specify that the <a href="http://en.wikipedia.org/wiki/Laplace_approximation">Laplace approximation</a> should be applied to any subset of the function arguments.<ul>
<li>Yields marginal likelihood in latent variable model.</li>
</ul>
</li>
<li>Standard deviations of any parameter, or derived parameter, obtained by the <a href="http://en.wikipedia.org/wiki/Delta_method">'delta method'</a>.</li>
<li>Pre and post-processing of data done in R.</li>
<li>TMB is based on state-of-the art software: <a href="http://www.coin-or.org/CppAD/">CppAD</a>, <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, ...</li>
</ul>
<p>A more general introduction including the underlying theory used in TMB can be found in this <a href="https://www.jstatsoft.org/index.php/jss/article/view/v070i05/v70i05.pdf">paper</a>.</p>
<h1><a class="anchor" id="Tutorial"></a>
Tutorial </h1>
<p>A TMB project consists of an R file (*.R) and a C++ file (*.cpp). The R file does pre- and post processing of data in addition to maximizing the log-likelihood contained in *.cpp. See <a href="#Examples">Examples</a> for more details. All R functions are documented within the standard help system in R. This tutorial describes how to write the C++ file, and assumes familiarity with C++ and to some extent with R.</p>
<p>The purpose of the C++ program is to evaluate the objective function, i.e. the negative log-likelihood of the model. The program is compiled and called from R, where it can be fed to a function minimizer like <code>nlminb()</code>.</p>
<p>The objective function should be of the following C++ type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TMB_8hpp.html">TMB.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line">Type objective_function&lt;Type&gt;::operator() ()</div><div class="line">{</div><div class="line">.... Here goes your C++ code ..... </div><div class="line">}</div></div><!-- fragment --><p>The first line includes the source code for the whole TMB package (and all its dependencies). The objective function is a templated class where <code>&lt;Type&gt;</code> is the data type of both the input values and the return value of the objective function. This allows us to evaluate both the objective function and its derivatives using the same chunk of C++ code (via the AD package <a href="http://www.coin-or.org/CppAD/Doc/doxydoc/html/index.html">CppAD</a>). The technical aspects of this are hidden from the user. There is however one aspect that surprises the new TMB user. When a constant like "1.2" is used in a calculation that affects the return value it must be "cast" to Type:</p>
<div class="fragment"><div class="line">Type nll;           <span class="comment">// Define variable that holds the return value (neg. log. lik)</span></div><div class="line">nll = Type(1.2);    <span class="comment">// Assign value 1.2; a cast is needed.</span></div></div><!-- fragment --><h2>Obtaining data and parameter values from R</h2>
<p>Obviously, we will need to pass both data and parameter values to the objective function. This is done through a set of macros that TMB defines for us.</p>
<h3>List of data macros</h3>
<blockquote class="doxtable">
<p><code><a class="el" href="group__macros.html#ga97c14a26ca75571090d332f15130ae4b" title="Get data array from R and declare it as array&lt;Type&gt; ">DATA_ARRAY()</a></code>, <code><a class="el" href="group__macros.html#gace5461529127e9c6f01c0b76b4fda2e6" title="Get data vector of type &quot;factor&quot; from R and declare it as a zero-based integer vector. ">DATA_FACTOR()</a></code>, <code><a class="el" href="group__macros.html#gaf5fe8a4b8a5134f341fa63844abb6fdc" title="Get data array from R and declare it as array&lt;int&gt; ">DATA_IARRAY()</a></code>, <code><a class="el" href="group__macros.html#gabccf17ca4aa07b903113927821f80cda" title="Get data matrix from R and declare it as matrix&lt;int&gt; ">DATA_IMATRIX()</a></code>, <code><a class="el" href="group__macros.html#gae361b76344dbd1c7cbf5073949211641" title="Get data scalar from R and declare it as int. ">DATA_INTEGER()</a></code>, <code><a class="el" href="group__macros.html#ga7889208e14a95d21cf630157cf0e2c80" title="Get data vector of type &quot;integer&quot; from R and declare it vector&lt;int&gt;. (DATA_INTEGER() is for a scalar ...">DATA_IVECTOR()</a></code>, <code><a class="el" href="group__macros.html#gada5d1729c6988c1060cfa456b56c8d8c" title="Get data matrix from R and declare it as matrix&lt;Type&gt; ">DATA_MATRIX()</a></code>, <code><a class="el" href="group__macros.html#ga5a9120a7b504f9502b5d1ce9d0c078ec" title="Get data scalar from R and declare it as Type. ">DATA_SCALAR()</a></code>, <code><a class="el" href="group__macros.html#ga75dbde3f78d762602b7ffc0f19a99e1e" title="Get sparse matrix from R and declare it as Eigen::SparseMatrix&lt;Type&gt; ">DATA_SPARSE_MATRIX()</a></code>, <code><a class="el" href="group__macros.html#gaba52ba9bd5c88f42a0ce96432aa6e688" title="Get string from R and declare it as std::string. ">DATA_STRING()</a></code>, <code><a class="el" href="group__macros.html#gaf9885566da0d248c1a4b4d7a0eeafcd2" title="Get data list object from R and make it available in C++. ">DATA_STRUCT()</a></code>, <code><a class="el" href="group__macros.html#ga3a3716228d46fbe32e23856b2f53be8d" title="Update a data object without re-taping. ">DATA_UPDATE()</a></code>, <code><a class="el" href="group__macros.html#gad334262a7679f343bdc919ae35810161" title="Get data vector from R and declare it as vector&lt;Type&gt; ">DATA_VECTOR()</a></code> </p>
</blockquote>
<h3>List of parameter macros</h3>
<blockquote class="doxtable">
<p><code><a class="el" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0" title="Get parameter scalar from R and declare it as Type. ">PARAMETER()</a></code>, <code><a class="el" href="group__macros.html#ga6ac3eddb1dd503ceaf4c6ac91546b23e" title="Get parameter array from R and declare it as array&lt;Type&gt; ">PARAMETER_ARRAY()</a></code>, <code><a class="el" href="group__macros.html#gabcad2a3c2d238178707c6c45de2d3bec" title="Get parameter matrix from R and declare it as matrix&lt;Type&gt; ">PARAMETER_MATRIX()</a></code>, <code><a class="el" href="group__macros.html#ga6b8a70eeee38fe896e89e0a9c6bef84a" title="Get parameter vector from R and declare it as vector&lt;Type&gt; ">PARAMETER_VECTOR()</a></code> </p>
</blockquote>
<p>To see which macros are available start typing <code>DATA_</code> or <code>PARAMETER_</code> in the Doxygen search field of your browser (you may need to refresh the browser window between each time you make a new search). A simple example if you want to read a vector of numbers (doubles) is the following</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);     <span class="comment">// Vector x(0),x(1),...,x(n-1), where n is the length of x</span></div></div><!-- fragment --><p>Note that all vectors and matrices in TMB uses a <b>zero-based</b> indexing scheme. It is not necessary to explicitly pass the dimension of <code>x</code>, as it can be retrieved inside the C++ program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n = x.size();</div></div><!-- fragment --><h2>An extended C++ language</h2>
<p>TMB extends C++ with functionality that is important for formulating likelihood functions. You have different toolboxes available:</p>
<ul>
<li>Standard C++ used for infrastructure like loops etc.</li>
<li>Vector, matrix and array library (see <a href="#matrix_arrays">Matrices and arrays</a>)</li>
<li>Probability distributions (see <a href="#Densities">Densities</a> and <a href="#R_style_distribution">R style distributions</a>)</li>
</ul>
<p>In addition to the variables defined through the <code>DATA_</code> or <code>PARAMETER_</code> macros there can be "local" variables, for which ordinary C++ scoping rules apply. There must also be a variable that holds the return value (neg. log. likelihood).</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);               <span class="comment">// Vector x(0), x(1), ..., x(n-1)</span></div><div class="line">Type tmp = x(1);</div><div class="line">Type nll = tmp * tmp; </div></div><!-- fragment --><p>As in ordinary C++ local variable tmp must be assigned a value before it can enter into a calculation.</p>
<h2>Statistical modelling</h2>
<p>TMB can handle complex statistical problems with hierarchical structure (latent random variables) and multiple data sources. Latent random variables must be continuous (discrete distributions are not handled). The <code>PARAMETER_</code> macros are used to pass two types of parameters.</p>
<ul>
<li><b>Parameters</b>: to be estimated by maximum likelihood. These include fixed effects and variance components in the mixed model literature. They will also correspond to hyper parameters with non-informative priors in the Bayesian literature.</li>
<li><b>Latent random variables</b>: to be integrated out of the likelihood using a Laplace approximation.</li>
</ul>
<p>Which of these are chosen is controlled from R, via the <code>random</code> argument to the function <code>MakeADFun</code>. However, on the C++ side it is usually necessary to assign a probability distribution to the parameter.</p>
<p>The purpose of the C++ program is to calculate the (negative) joint density of data and latent random variables. Each datum and individual latent random effect gives a contribution to log likelihood, which may be though of as a "distribution assignment" by users familiar with software in the BUGS family.</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#ga6b8a70eeee38fe896e89e0a9c6bef84a">PARAMETER_VECTOR</a>(u);          <span class="comment">// Latent random variable </span></div><div class="line">Type nll = Type(0);           <span class="comment">// Return value</span></div><div class="line">nll -= <a class="code" href="group__R__style__distribution.html#ga5eb914782c488bd3ec4a50d4e4a73394">dnorm</a>(u(0),0,1,<span class="keyword">true</span>)   <span class="comment">// Distributional assignment: u(0) ~ N(0,1) </span></div></div><!-- fragment --><p>The following rules apply:</p>
<ul>
<li>Distribution assignments do not need to take place before the latent variable is used in a calculation.</li>
<li>More complicated distributional assignments are allowed, say <em>u(0)-u(1) ~ N(0,1)</em>, but this requires the user to have a deeper understanding of the probabilistic aspects of the model.</li>
<li>For latent variables only normal distributions should be used (otherwise the Laplace approximation will perform poorly). For response variables all probability distributions (discrete or continuous) are allowed. If a non-gaussian latent is needed the "transformation trick" can be used.</li>
<li>The namespaces <a href="#R_style_distribution">R style distributions</a> and <a href="#Densities">Densities</a> contain many probability distributions, including multivariate normal distributions. For probability distributions not available from these libraries, the user can use raw C++ code:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(y);                   <span class="comment">// Data vector</span></div><div class="line">Type nll = Type(0);               <span class="comment">// Return value</span></div><div class="line">nll -= <a class="code" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>(-log(Type(1.0)+y*y));  <span class="comment">// y are i.i.d. Cauchy distributed</span></div></div><!-- fragment --><p>See <a href="#Toolbox">Toolbox</a> for more about statistical modelling.</p>
<h1><a class="anchor" id="Structure_TMB"></a>
The structure of TMB </h1>
<p>This documentation only covers the TMB specific code, not <a href="http://www.coin-or.org/CppAD/Doc/doxydoc/html/index.html">CppAD</a> or <a href="http://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen</a> These packages have their own documentation, which may be relevant. In particular, some of the standard functions like <code>sin()</code> and <code>cos()</code> are part of CppAD, and are hence not documented through TMB.</p>
<div class="image">
<img src="TMB_components.png" alt="TMB_components.png"/>
<div class="caption">
TMB components</div></div>
<h1><a class="anchor" id="matrix_arrays"></a>
Matrices and arrays </h1>
<h2>Relationship to R</h2>
<p>In R you can apply both matrix multiplication (<code>%*%</code>) and elementwise multiplication (<code>*</code>) to objects of type "matrix", i.e. it is the operator that determines the operation. In TMB we instead have two different types of objects, while the multiplication operator (<code>*</code>) is the same:</p>
<ul>
<li><code>matrix</code>: linear algebra</li>
<li><code>array</code>: elementwise operations; () and [] style indexing.</li>
<li><code>vector</code>: can be used in linear algebra with <code>matrix</code>, but at the same time admits R style element-wise operations.</li>
</ul>
<p>See the file <a class="el" href="matrix_arrays_8cpp-example.html">matrix_arrays.cpp</a> for examples of use.</p>
<h2>Relationship to Eigen</h2>
<p>The TMB types <code>matrix</code> and <code>array</code> (in dimension 2) inherits directly from the the Eigen types Matrix and Array. The advanced user of TMB will benefit from familiarity with the <a href="http://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen documentation</a>. Note that arrays of dimension 3 or higher are specially implemented in TMB, i.e. are not directly inherited from Eigen.</p>
<h1><a class="anchor" id="R_style_distribution"></a>
R style probability distributions </h1>
<p>Attempts have been made to make the interface (function name and arguments) as close as possible to that of R.</p>
<ul>
<li>The densities (<code>d...</code>) are provided both in the discrete and continuous case, cumulative distributions (<code>p...</code>) and inverse cumulative distributions (<code>q...</code>) are provided only for continuous distributions.</li>
<li>Scalar and <code>vector</code> arguments (in combination) are supported, but not <code>array</code> or <code>matrix</code> arguments.</li>
<li>The last argument (of type <code>int</code>) corresponds to the <code>log</code> argument in R: 1=logaritm, 0=ordinary scale. <code>true</code> (logaritm) and <code>false</code> (ordinary scale) can also be used.</li>
<li>Vector arguments must all be of the same length (no recycling of elements). If vectors of different lengths are used an "out of
  range" error will occur, which can be picked up by the debugger.</li>
<li><code><a class="el" href="group__macros.html#ga7889208e14a95d21cf630157cf0e2c80" title="Get data vector of type &quot;integer&quot; from R and declare it vector&lt;int&gt;. (DATA_INTEGER() is for a scalar ...">DATA_IVECTOR()</a></code> and <code><a class="el" href="group__macros.html#gae361b76344dbd1c7cbf5073949211641" title="Get data scalar from R and declare it as int. ">DATA_INTEGER()</a></code> cannot be used with probability distributions, except possibly for the last (log) argument.</li>
<li>An example:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#ga5a9120a7b504f9502b5d1ce9d0c078ec">DATA_SCALAR</a>(y);</div><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);</div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> rate(10);</div><div class="line"><a class="code" href="structmatrix.html">matrix&lt;Type&gt;</a> rate_matrix(10, 10);</div><div class="line"><a class="code" href="group__R__style__distribution.html#gaf2fbecc2d174db6274a81e65559c69e8">dexp</a>(y, rate, <span class="keyword">true</span>);                    <span class="comment">// OK, returns vector of length 10 of log-densities</span></div><div class="line"><a class="code" href="group__R__style__distribution.html#gaf2fbecc2d174db6274a81e65559c69e8">dexp</a>(x, rate, <span class="keyword">true</span>);                    <span class="comment">// OK if x is length 10</span></div><div class="line"><a class="code" href="group__R__style__distribution.html#gaf2fbecc2d174db6274a81e65559c69e8">dexp</a>(x, rate_matrix, <span class="keyword">true</span>);             <span class="comment">// Error, matrix arguments not allowed</span></div></div><!-- fragment --><ul>
<li>To sum over elements in the vector returned use</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>(<a class="code" href="group__R__style__distribution.html#gaf2fbecc2d174db6274a81e65559c69e8">dexp</a>(x,rate));</div></div><!-- fragment --><h1><a class="anchor" id="Densities"></a>
Multivariate distributions </h1>
<p>The namespace</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div></div><!-- fragment --><p>gives access to a variety of multivariate normal distributions:</p>
<ul>
<li>Multivariate normal distributions specified via a covariance matrix (structured or unstructured).</li>
<li>Autoregressive (AR) processes.</li>
<li>Gaussian Markov random fields (GMRF) defined on regular grids or defined via a (sparse) precision matrix.</li>
<li>Separable covariance functions, i.e. time-space separability.</li>
</ul>
<p>These seemingly unrelated concepts are all implemented via the notion of a <code>distribution</code>, which explains why they are placed in the same namespace. You can combine two <code>distributions</code>, and this lets you build up complex multivariate distributions using extremely compact notation. Due to the flexibility of the approach it is more abstract than other parts of TMB, but here it will be explained from scratch. Before looking at the different categories of multivariate distributions we note the following which is of practical importance:</p>
<ul>
<li>All members in the <code>density</code> namespace return the <b>negative</b> log density, opposed to the univariate densities in <a href="#R_style_distribution">R style distributions</a>.</li>
</ul>
<h2>Multivariate normal distributions</h2>
<p>Consider a zero-mean multivariate normal distribution with covariance matrix <em>Sigma</em> (symmetric positive definite), that we want to evaluate at <em>x</em>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 10;</div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> x(n);           <span class="comment">// Evaluation point           </span></div><div class="line">x.fill(0.0);                 <span class="comment">// Point of evaluation: x = (0,0,...,0)</span></div></div><!-- fragment --><p>The negative log-normal density is evaluated as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div><div class="line"><a class="code" href="structmatrix.html">matrix&lt;Type&gt;</a> Sigma(n,n);     <span class="comment">// Covariance matrix</span></div><div class="line"><span class="comment">// ..... User must assign value to Sigma here</span></div><div class="line">res = <a class="code" href="namespacedensity.html#a0721aacc998f4cbd0290626073c19763">MVNORM</a>(Sigma)(x);      <span class="comment">// Evaluate negative log likelihod</span></div></div><!-- fragment --><p>In the last line <code>MVNORM(Sigma)</code> should be interpreted as a multivariate density, which via the last parenthesis <code>(x)</code> is evaluated at <code>x</code>. A less compact way of expressing this is</p>
<div class="fragment"><div class="line">MVNORM_t&lt;Type&gt; your_dmnorm(Sigma);</div><div class="line">res = your_dmnorm(x);</div></div><!-- fragment --><p>in which <code>your_dmnorm</code> is a variable that holds the "density".</p>
<p>Note, that the latter way (using the <code>MVNORM_t</code>) is <em>more efficient</em> when you need to evaluate the density more than once, i.e. for different values of <code>x</code>.</p>
<p><em>Sigma</em> can be parameterized in different ways. Due to the symmetry of <em>Sigma</em> there are at most <em>n(n+1)/2</em> free parameters (<em>n</em> variances and <em>n(n-1)/2</em> correlation parameters). If you want to estimate all of these freely (modulo the positive definite constraint) you can use <code><a class="el" href="namespacedensity.html#aec3874ac89bc3a5d5d4d245db46b09e4" title="Construct object to evaluate the density with unstructured correlation matrix. See UNSTRUCTURED_CORR_...">UNSTRUCTURED_CORR()</a></code> to specify the correlation matrix, and <code><a class="el" href="namespacedensity.html#ad4883b13b683e6b9e1e27846b74e4680" title="Construct object to evaluate a scaled density. See VECSCALE_t for details. ">VECSCALE()</a></code> to specify variances. <code><a class="el" href="namespacedensity.html#aec3874ac89bc3a5d5d4d245db46b09e4" title="Construct object to evaluate the density with unstructured correlation matrix. See UNSTRUCTURED_CORR_...">UNSTRUCTURED_CORR()</a></code> takes as input a vector a dummy parameters that internally is used to build the correlation matrix via its cholesky factor.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div><div class="line"><span class="keywordtype">int</span> n = 10;</div><div class="line">vector&lt;Type&gt; unconstrained_params(n*(n-1)/2);  <span class="comment">// Dummy parameterization of correlation matrix</span></div><div class="line">vector&lt;Type&gt; sds(n);                           <span class="comment">// Standard deviations</span></div><div class="line">res = <a class="code" href="namespacedensity.html#ad4883b13b683e6b9e1e27846b74e4680">VECSCALE</a>(<a class="code" href="namespacedensity.html#aec3874ac89bc3a5d5d4d245db46b09e4">UNSTRUCTURED_CORR</a>(unconstrained_params),sds)(x);</div></div><!-- fragment --><p>If all elements of <code>dummy_params</code> are estimated we are in effect estimating a full correlation matrix without any constraints on its elements (except for the mandatory positive definiteness). The actual value of the correlation matrix, but not the full covariance matrix, can easily be assessed using the <code>.cov()</code> operator</p>
<div class="fragment"><div class="line"><a class="code" href="structmatrix.html">matrix&lt;Type&gt;</a> Sigma(n,n);</div><div class="line">Sigma = <a class="code" href="namespacedensity.html#aec3874ac89bc3a5d5d4d245db46b09e4">UNSTRUCTURED_CORR</a>(unconstrained_params).cov();</div><div class="line"><a class="code" href="group__macros.html#gac2d7888f4e0385930448f992de53079b">REPORT</a>(Sigma);                                         <span class="comment">// Report back to R session</span></div></div><!-- fragment --><h2>Autoregressive processes</h2>
<p>Consider a stationary univariate Gaussian AR1 process <em>x(t),t=0,...,n-1</em>. The stationary distribution is choosen so that:</p>
<ul>
<li><em>x(t)</em> has mean 0 and variance 1 (for all <em>t</em>).</li>
</ul>
<p>The multivariate density of the vector <em>x</em> can be evaluated as follows</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 10;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div><div class="line"></div><div class="line">vector&lt;Type&gt; x(n);           <span class="comment">// Evaluation point</span></div><div class="line">x.fill(0.0);                 <span class="comment">// Point of evaluation: x = (0,0,...,0)</span></div><div class="line">Type rho = 0.2;              <span class="comment">// Correlation parameter</span></div><div class="line">res = AR1(rho)(x);           <span class="comment">// Evaluate negative log-density of AR1 process at point x </span></div></div><!-- fragment --><p>Due to the assumed stationarity the correlation parameter must satisfy:</p>
<ul>
<li><b>Stationarity</b> constraint: -1 &lt; <em>rho</em> &lt; 1</li>
</ul>
<p>Note that <em>cor[x(t),x(t-1)] = rho</em>.</p>
<p>The <code>SCALE()</code> function can be used to set the standard deviation.</p>
<div class="fragment"><div class="line">Type sigma = 2.1;            <span class="comment">// standard deviation of x</span></div><div class="line">res = SCALE(AR1(rho),sigma)(x);</div></div><!-- fragment --><p>Now, <em>var[x(t)] = sigma^2</em>. Because all elements of <code>x</code> are scaled by the same constant we use SCALE rather than VECSCALE.</p>
<h4>Multivariate AR1 processes</h4>
<p>This is the first real illustration of how distributions can be used as building blocks to obtain more complex distributions. Consider the <em>p</em> dimensional AR1 process</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 10;                   <span class="comment">// Number of time steps</span></div><div class="line"><span class="keywordtype">int</span> p=3;                      <span class="comment">// dim(x)</span></div><div class="line"><a class="code" href="structarray.html">array&lt;Type&gt;</a> x(p,n);           <span class="comment">// Evaluation point</span></div></div><!-- fragment --><p>The columns in <code>x</code> refer to the different time points. We then evaluate the (negative log) joint density of the time series.</p>
<div class="fragment"><div class="line">MVNORM_t&lt;Type&gt; your_dmnorm(Sigma);  <span class="comment">// Density of x(t) </span></div><div class="line">Type phi;                           <span class="comment">// Correlation parameter</span></div><div class="line">res = AR1(phi,your_dmnorm)(x);</div></div><!-- fragment --><p>Note the following:</p>
<ul>
<li>We have introduced an intermediate variable <code>your_dmnorm</code>, which holds the p-dim density marginal density of <em>x(t)</em>. This is a zero-mean normal density with covariance matrix <code>Sigma</code>.</li>
<li>All <em>p</em> univarite time series have the same serial correlation <em>phi</em>.</li>
<li>The multivariate process <em>x(t)</em> is stationary in the same sense as the univariate AR1 process described above.</li>
</ul>
<h4>Higher order AR processes</h4>
<p>There also exists ARk_t of arbitrary autoregressive order.</p>
<h2>Gaussian Markov random fields (GMRF)</h2>
<p>GMRF may be defined in two ways:</p>
<ol type="1">
<li>Via a (sparse) precision matrix Q.</li>
<li>Via a d-dimensional lattice.</li>
</ol>
<p>For further details please see GMRF_t. Under 1) a sparse Q corresponding to a Matern covariance function can be obtained via the <a class="el" href="namespaceR__inla.html">R_inla</a> namespace.</p>
<h2>Separable construction of covariance (precision) matrices</h2>
<p>A typical use of separability is to create space-time models with a sparse precision matrix. Details are given in SEPARABLE_t. Here we give a simple example.</p>
<p>Assume that we study a quantity <code>x</code> that changes both in space and time. For simplicity we consider only a one-dimensional space. We discretize space and time using equidistant grids, and assume that the distance between grid points is 1 in both dimensions. We then define an <code>AR1(rho_s)</code> process in space and one in time <code>AR1(rho_t)</code>. The separable assumption is that two points <code>x1</code> and <code>x2</code>, separated in space by a distance <code>ds</code> and in time by a distance <code>dt</code>, have correlation given by</p>
<p><code>rho_s^ds*rho_t^dt</code></p>
<p>This is implemented as</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div><div class="line"><span class="keywordtype">int</span> n_s = 10;                   <span class="comment">// Number of grid points in space</span></div><div class="line"><span class="keywordtype">int</span> n_t = 10;                   <span class="comment">// Number of grid points in time</span></div><div class="line">Type rho_s = 0.2;               <span class="comment">// Correlation in space</span></div><div class="line">Type rho_t = 0.4;               <span class="comment">// Correlation in time</span></div><div class="line"></div><div class="line"><a class="code" href="structarray.html">array&lt;Type&gt;</a> x(n_s,n_t);</div><div class="line">x.setZero();                    <span class="comment">// x = 0</span></div><div class="line"></div><div class="line">res = <a class="code" href="namespacedensity.html#a7163798c4b0467ac2e570b034d7ca4c5">SEPARABLE</a>(AR1(rho_t),AR1(rho_s))(x);</div></div><!-- fragment --><p>Note that the arguments to <code><a class="el" href="namespacedensity.html#a7163798c4b0467ac2e570b034d7ca4c5" title="Construct object to evaluate the separable extension of two multivariate zero-mean normal densities...">SEPARABLE()</a></code> are given in the opposite order to the dimensions of <code>x</code>.</p>
<h1><a class="anchor" id="Examples"></a>
Example collection </h1>
<ul>
<li>A list of all examples is found on the "Examples" tab on the top of the page.</li>
<li>Locations of example files: <code>adcomp/tmb_examples</code> and <code>adcomp/TMB/inst/examples</code>.</li>
<li>For each example there is both a <code>.cpp</code> <b>and</b> a <code>.R</code> file. Take for instance the linear regression example:</li>
<li><b>C++ template</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Simple linear regression.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TMB_8hpp.html">TMB.hpp</a>&gt;</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line">Type objective_function&lt;Type&gt;::operator() ()</div><div class="line">{</div><div class="line">  <a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(Y);</div><div class="line">  <a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);</div><div class="line">  <a class="code" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0">PARAMETER</a>(a);</div><div class="line">  <a class="code" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0">PARAMETER</a>(b);</div><div class="line">  <a class="code" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0">PARAMETER</a>(logSigma);</div><div class="line">  <a class="code" href="group__macros.html#ga43a13c435127491364e4a167478f4992">ADREPORT</a>(exp(2*logSigma));</div><div class="line">  Type nll = -<a class="code" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>(<a class="code" href="group__R__style__distribution.html#ga5eb914782c488bd3ec4a50d4e4a73394">dnorm</a>(Y, a+b*x, exp(logSigma), <span class="keyword">true</span>));</div><div class="line">  <span class="keywordflow">return</span> nll;</div><div class="line">}</div></div><!-- fragment --><ul>
<li><b>Controlling R code</b></li>
</ul>
<div class="fragment"><div class="line">library(TMB)</div><div class="line">compile(&quot;linreg.cpp&quot;)</div><div class="line">dyn.load(dynlib(&quot;linreg&quot;))</div><div class="line">set.seed(123)</div><div class="line">data &lt;- list(Y = rnorm(10) + 1:10, x=1:10)</div><div class="line">parameters &lt;- list(a=0, b=0, logSigma=0)</div><div class="line">obj &lt;- MakeADFun(data, parameters, DLL=&quot;linreg&quot;)</div><div class="line">obj$hessian &lt;- TRUE</div><div class="line">opt &lt;- do.call(&quot;optim&quot;, obj)</div><div class="line">opt</div><div class="line">opt$hessian ## &lt;-- FD hessian from optim</div><div class="line">obj$he()    ## &lt;-- Analytical hessian</div><div class="line">sdreport(obj)</div></div><!-- fragment --><ul>
<li>To run this example use the R command</li>
</ul>
<div class="fragment"><div class="line">source(&quot;linreg.R&quot;)</div></div><!-- fragment --><h2>Example overview</h2>
<table class="doxtable">
<tr>
<th align="left">Example </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><a class="el" href="adaptive_integration_8cpp-example.html">adaptive_integration.cpp</a> </td><td align="left">Adaptive integration using 'tiny_ad' </td></tr>
<tr>
<td align="left"><a class="el" href="ar1_4D_8cpp-example.html">ar1_4D.cpp</a> </td><td align="left">Separable covariance on 4D lattice with AR1 structure in each direction. </td></tr>
<tr>
<td align="left"><a class="el" href="compois_8cpp-example.html">compois.cpp</a> </td><td align="left">Conway-Maxwell-Poisson distribution </td></tr>
<tr>
<td align="left"><a class="el" href="fft_8cpp-example.html">fft.cpp</a> </td><td align="left">Multivariate normal distribution with circulant covariance </td></tr>
<tr>
<td align="left"><a class="el" href="hmm_8cpp-example.html">hmm.cpp</a> </td><td align="left">Inference in a 'double-well' stochastic differential equation using HMM filter. </td></tr>
<tr>
<td align="left"><a class="el" href="laplace_8cpp-example.html">laplace.cpp</a> </td><td align="left">Laplace approximation from scratch demonstrated on 'spatial' example. </td></tr>
<tr>
<td align="left"><a class="el" href="linreg_parallel_8cpp-example.html">linreg_parallel.cpp</a> </td><td align="left">Parallel linear regression. </td></tr>
<tr>
<td align="left"><a class="el" href="linreg_8cpp-example.html">linreg.cpp</a> </td><td align="left">Simple linear regression. </td></tr>
<tr>
<td align="left"><a class="el" href="longlinreg_8cpp-example.html">longlinreg.cpp</a> </td><td align="left">Linear regression - 10^6 observations. </td></tr>
<tr>
<td align="left"><a class="el" href="lr_test_8cpp-example.html">lr_test.cpp</a> </td><td align="left">Illustrate map feature of TMB to perform likelihood ratio tests on a ragged array dataset. </td></tr>
<tr>
<td align="left"><a class="el" href="matern_8cpp-example.html">matern.cpp</a> </td><td align="left">Gaussian process with Matern covariance. </td></tr>
<tr>
<td align="left"><a class="el" href="mvrw_sparse_8cpp-example.html">mvrw_sparse.cpp</a> </td><td align="left">Identical with random walk example. Utilizing sparse block structure so efficient when the number of states is high. </td></tr>
<tr>
<td align="left"><a class="el" href="mvrw_8cpp-example.html">mvrw.cpp</a> </td><td align="left">Random walk with multivariate correlated increments and measurement noise. </td></tr>
<tr>
<td align="left"><a class="el" href="nmix_8cpp-example.html">nmix.cpp</a> </td><td align="left">nmix example from <a href="https://groups.nceas.ucsb.edu/non-linear-modeling/projects/nmix">https://groups.nceas.ucsb.edu/non-linear-modeling/projects/nmix</a> </td></tr>
<tr>
<td align="left"><a class="el" href="orange_big_8cpp-example.html">orange_big.cpp</a> </td><td align="left">Scaled up version of the Orange Tree example (5000 latent random variables) </td></tr>
<tr>
<td align="left"><a class="el" href="register_atomic_parallel_8cpp-example.html">register_atomic_parallel.cpp</a> </td><td align="left">Parallel version of 'register_atomic' </td></tr>
<tr>
<td align="left"><a class="el" href="register_atomic_8cpp-example.html">register_atomic.cpp</a> </td><td align="left">Similar to example 'adaptive_integration' using CppAD Romberg integration. REGISTER_ATOMIC is used to reduce tape size. </td></tr>
<tr>
<td align="left"><a class="el" href="sam_8cpp-example.html">sam.cpp</a> </td><td align="left">State space assessment model from Nielsen and Berg 2014, Fisheries Research. </td></tr>
<tr>
<td align="left"><a class="el" href="sde_linear_8cpp-example.html">sde_linear.cpp</a> </td><td align="left">Inference in a linear scalar stochastic differential equation. </td></tr>
<tr>
<td align="left"><a class="el" href="sdv_multi_compact_8cpp-example.html">sdv_multi_compact.cpp</a> </td><td align="left">Compact version of sdv_multi </td></tr>
<tr>
<td align="left"><a class="el" href="sdv_multi_8cpp-example.html">sdv_multi.cpp</a> </td><td align="left">Multivatiate SV model from Skaug and Yu 2013, Comp. Stat &amp; data Analysis (to appear) </td></tr>
<tr>
<td align="left"><a class="el" href="socatt_8cpp-example.html">socatt.cpp</a> </td><td align="left">socatt from ADMB example collection. </td></tr>
<tr>
<td align="left"><a class="el" href="spatial_8cpp-example.html">spatial.cpp</a> </td><td align="left">Spatial poisson GLMM on a grid, with exponentially decaying correlation function </td></tr>
<tr>
<td align="left"><a class="el" href="spde_aniso_speedup_8cpp-example.html">spde_aniso_speedup.cpp</a> </td><td align="left">Speedup "spde_aniso.cpp" by moving normalization out of the template. </td></tr>
<tr>
<td align="left"><a class="el" href="spde_aniso_8cpp-example.html">spde_aniso.cpp</a> </td><td align="left">Anisotropic version of "spde.cpp". </td></tr>
<tr>
<td align="left"><a class="el" href="spde_8cpp-example.html">spde.cpp</a> </td><td align="left">Illustration SPDE/INLA approach to spatial modelling via Matern correlation function </td></tr>
<tr>
<td align="left"><a class="el" href="thetalog_8cpp-example.html">thetalog.cpp</a> </td><td align="left">Theta logistic population model from Pedersen et al 2012, Ecol. Modelling. </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2interpol_8cpp-example.html">TMBad/interpol.cpp</a> </td><td align="left">Demonstrate 2D interpolation operator </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2sam_8cpp-example.html">TMBad/sam.cpp</a> </td><td align="left">State space assessment model from Nielsen and Berg 2014, Fisheries Research. </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2solver_8cpp-example.html">TMBad/solver.cpp</a> </td><td align="left">Demonstrate adaptive solver of <a class="el" href="namespaceTMBad.html" title="Automatic differentiation library designed for TMB. ">TMBad</a> </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2spa_gauss_8cpp-example.html">TMBad/spa_gauss.cpp</a> </td><td align="left">Demonstrate saddlepoint approximation (SPA) </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2spatial_8cpp-example.html">TMBad/spatial.cpp</a> </td><td align="left">Spatial poisson GLMM on a grid, with exponentially decaying correlation function </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2spde_epsilon_8cpp-example.html">TMBad/spde_epsilon.cpp</a> </td><td align="left">Low-level demonstration of fast epsilon bias correction using 'sparse plus lowrank' hessian </td></tr>
<tr>
<td align="left"><a class="el" href="TMBad_2thetalog_8cpp-example.html">TMBad/thetalog.cpp</a> </td><td align="left">Theta logistic population model from Pedersen et al 2012, Ecol. Modelling. </td></tr>
<tr>
<td align="left"><a class="el" href="transform_parallel_8cpp-example.html">transform_parallel.cpp</a> </td><td align="left">Parallel version of transform </td></tr>
<tr>
<td align="left"><a class="el" href="transform_8cpp-example.html">transform.cpp</a> </td><td align="left">Gamma distributed random effects using copulas. </td></tr>
<tr>
<td align="left"><a class="el" href="transform2_8cpp-example.html">transform2.cpp</a> </td><td align="left">Beta distributed random effects using copulas. </td></tr>
<tr>
<td align="left"><a class="el" href="tweedie_8cpp-example.html">tweedie.cpp</a> </td><td align="left">Estimating parameters in a Tweedie distribution. </td></tr>
<tr>
<td align="left"><a class="el" href="validation_2MVRandomWalkValidation_8cpp-example.html">validation/MVRandomWalkValidation.cpp</a> </td><td align="left">Estimate and validate a multivariate random walk model with correlated increments and correlated observations. </td></tr>
<tr>
<td align="left"><a class="el" href="validation_2randomwalkvalidation_8cpp-example.html">validation/randomwalkvalidation.cpp</a> </td><td align="left">Estimate and validate a random walk model with and without drift </td></tr>
<tr>
<td align="left"><a class="el" href="validation_2rickervalidation_8cpp-example.html">validation/rickervalidation.cpp</a> </td><td align="left">Estimate and validate a Ricker model based on data simulated from the logistic map </td></tr>
</table>
<h1><a class="anchor" id="Errors"></a>
Compilation and run time errors </h1>
<p>The R interface to the debugger (gdb) is documented as part of the R help system, i.e. you can type <code>?gdbsource</code> in R to get info. The current document only adresses isses that the relate to C++.</p>
<h2>Compilation errors</h2>
<p>It may be hard to understand the compilation errors for the following reasons</p>
<ul>
<li>The Eigen libraries use templated C++ which generate non-intuitive error messages.</li>
</ul>
<h2>Run time errors</h2>
<p>Run time errors are broadly speaking of two types:</p>
<ul>
<li>Out-of-bounds (you are "walking out of an array")</li>
<li>Floating point exceptions</li>
</ul>
<p>You can use the debugger to locate both types of errors, but the procedure is a little bit different in the two cases. The following assumes that you have the GNU debugger <code>gdb</code> installed.</p>
<h3>Out-of-bounds error</h3>
<p>An example is:</p>
<div class="fragment"><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> y(4);</div><div class="line">y(5);                <span class="comment">// 5 is not a valid index value here</span></div></div><!-- fragment --><p>This will cause TMB and R to crash with the following error message:</p>
<blockquote class="doxtable">
<p>TMB has received an error from Eigen. The following condition was not met: index &gt;= 0 &amp;&amp; index &lt; size() Please check your matrix-vector bounds etc., or run your program through a debugger. Aborted (core dumped) </p>
</blockquote>
<p>So, you must restart R and give the commands</p>
<div class="fragment"><div class="line">library(TMB)</div><div class="line">gdbsource(&quot;my_project.R&quot;)</div></div><!-- fragment --><blockquote class="doxtable">
<p>#5 objective_function&lt;double&gt;::operator() (this=&lt;optimized out&gt;=""&gt;) at nan_error_ex.cpp:11 </p>
</blockquote>
<p>and you can see that the debugger points to line number 11 in the .cpp file. <code>gdbsource()</code> is an R function that is part of TMB.</p>
<h3>Floating point exception</h3>
<p>If you on the other hand perform an illegal mathematical operation, such as</p>
<div class="fragment"><div class="line">Type f = sqrt(-1.);</div></div><!-- fragment --><p>R will not crash, but the objective function will return a NaN value. However, you will not know in which part of your C++ code the error occured. By including the <code>fenv.h</code> library (part of many C++ compilers, but can otherwise be downloaded from <a href="http://www.scs.stanford.edu/histar/src/uinc/fenv.h">http://www.scs.stanford.edu/histar/src/uinc/fenv.h</a>)</p>
<p><code>nan_error_ex.cpp</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Illustrates how to make the debugger catch a floating point error.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="TMB_8hpp.html">TMB.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fenv.h&gt;</span> <span class="comment">// Extra line needed</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line">Type objective_function&lt;Type&gt;::operator() ()</div><div class="line">{</div><div class="line">  feenableexcept(FE_INVALID | FE_OVERFLOW | FE_DIVBYZERO | FE_UNDERFLOW); <span class="comment">// Extra line needed</span></div><div class="line"></div><div class="line">  <a class="code" href="group__macros.html#ga5a9120a7b504f9502b5d1ce9d0c078ec">DATA_SCALAR</a>(lambda);</div><div class="line">  <a class="code" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0">PARAMETER</a>(x);</div><div class="line">  Type f;</div><div class="line">  f = sqrt(-1.);        <span class="comment">// FE_INVALID   ( sqrt(-1.) returns NaN )</span></div><div class="line">  <span class="comment">//f = 1./0.;          // FE_DIVBYZERO ( division by zero )</span></div><div class="line">  <span class="comment">//f = exp(100000.);   // FE_OVERFLOW  ( exp(100000.) returns Inf )   [Does not work on all platforms]</span></div><div class="line">  <span class="comment">//f = exp(-100000.);  // FE_UNDERFLOW ( exp(-100000.) returns 0 )</span></div><div class="line">  <span class="keywordflow">return</span> f;</div><div class="line">}</div></div><!-- fragment --><p>a floating point exception will be turned into an actual error that can be picked up by the debugger. There are only two extra lines that need to be included ("//Extra line needed" in the above example).</p>
<p>When we try to run this program in the usual way, the program crashes:</p>
<div class="fragment"><div class="line">source(&quot;nan_error_ex.R&quot;)</div></div><!-- fragment --><blockquote class="doxtable">
<p>Floating point exception (core dumped) tmp3&gt; </p>
</blockquote>
<p>At this stage you should run the debugger to find out that the floating point exception occurs at line number 14:</p>
<div class="fragment"><div class="line">library(TMB)</div><div class="line">gdbsource(&quot;nan_error_ex.R&quot;)</div></div><!-- fragment --><blockquote class="doxtable">
<p>#1 0x00007ffff0e7eb09 in objective_function&lt;double&gt;::operator() (this=&lt;optimized out&gt;=""&gt;) at nan_error_ex.cpp:14 </p>
</blockquote>
<p>This enabling of floating point errors applies to R as well as the TMB program. For more elaborate R-scripts it may therefore happen that a NaN occurs in the R-script before the floating point exception in the TMB program (i.e. the problem of interest) happens. To circumvent this problem one can run without NaN debugging enabled and save the parameter vector that gave the floating point exception (e.g. <code>badpar &lt;- obj$env$last.par</code> after the NaN evaluation), then enable NaN debugging, re-compile, and evaluate <code>obj$env$f( badpar, type="double")</code>.</p>
<h3>Missing casts for vectorized functions</h3>
<p>TMB vectorized functions cannot be called directly with expressions, for example the following will fail to compile:</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);</div><div class="line"><span class="comment">// Don&#39;t do this! Doesn&#39;t compile</span></div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> out = <a class="code" href="group__special__functions.html#ga177b023eb871927fcfc90259e9f00382">lgamma</a>(x + 1);</div></div><!-- fragment --><blockquote class="doxtable">
<p>error: could not convert ‘atomic::D_lgamma(const CppAD::vector&lt;Type&gt;&amp;) ... from ‘double’ to ‘Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_sum_op&lt;double, double&gt;, ... &gt;’ </p>
</blockquote>
<p>Eigen lazy-evaluates expressions, and the templating of lgamma means we expect to return a "x + y"-typed object, which it obviously can't do.</p>
<p>To work around this, cast the input:</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);</div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> out = <a class="code" href="group__special__functions.html#ga177b023eb871927fcfc90259e9f00382">lgamma</a>(<a class="code" href="structvector.html">vector&lt;Type&gt;</a>(x + 1));</div></div><!-- fragment --><h1><a class="anchor" id="Toolbox"></a>
Toolbox </h1>
<p>First read the <em>Statistical Modelling</em> section of <a href="#Tutorial">Tutorial</a>.</p>
<h3>Non-normal latent variables (random effects)</h3>
<p>The underlying latent random variables in TMB must be Gaussian for the Laplace approximation to be accurate. To obtain other distributions, say a gamma distribution, the "transformation trick" can be used. We start out with normally distributed variables <code>u</code> and transform these into new variables <code>w</code> via the <code>pnorm</code> and <code>qgamma</code> functions as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#ga6b8a70eeee38fe896e89e0a9c6bef84a">PARAMETER_VECTOR</a>(u);                             <span class="comment">// Underlying latent random variables </span></div><div class="line">Type nll=Type(0.0);</div><div class="line">nll -= <a class="code" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>(<a class="code" href="group__R__style__distribution.html#ga5eb914782c488bd3ec4a50d4e4a73394">dnorm</a>(u,Type(0),Type(1),<span class="keyword">true</span>));       <span class="comment">// Assign N(0,1) distribution u </span></div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> v = <a class="code" href="group__R__style__distribution.html#ga2a3cc5a06500670aeaf6eb911a1094d9">pnorm</a>(u,Type(0),Type(1));  <span class="comment">// Uniformly distributed variables (on [0,1])</span></div><div class="line"><a class="code" href="structvector.html">vector&lt;Type&gt;</a> w = <a class="code" href="group__R__style__distribution.html#ga0e4b623b592b42651357611532e2b912">qgamma</a>(v,shape,scale);</div></div><!-- fragment --><p><code>w</code> now has a gamma distribution.</p>
<h3>Discrete latent variables</h3>
<p>The Laplace approximation can not be applied to discrete latent variables that occur in mixture models and HMMs (Hidden Markov models). However, such likelihoods have analytic expressions, and may be coded up in TMB. TMB would still calculate the exact gradient of the HMM likelihood.</p>
<h3>Mixture models</h3>
<p>Although mixture models are a special case of discrete latent variable models, they do deserve special attention. Consider the case that we want a mixture of two zero-mean normal distributions (with different standard deviations). This can be implemented as:</p>
<div class="fragment"><div class="line"><a class="code" href="group__macros.html#gad334262a7679f343bdc919ae35810161">DATA_VECTOR</a>(x);                                 </div><div class="line"><a class="code" href="group__macros.html#ga6b8a70eeee38fe896e89e0a9c6bef84a">PARAMETER_VECTOR</a>(sigma);      <span class="comment">// sigma0 og sigma1</span></div><div class="line"><a class="code" href="group__macros.html#ga70b2d449f7c53e87abee7d5fb71dc4c0">PARAMETER</a>(p);                 <span class="comment">// Mixture proportion of model 0</span></div><div class="line">Type nll=Type(0.0);</div><div class="line">nll -= <a class="code" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>( log(      p  * <a class="code" href="group__R__style__distribution.html#ga5eb914782c488bd3ec4a50d4e4a73394">dnorm</a>(x, Type(0), sigma(0), <span class="keyword">false</span>)</div><div class="line">               + (1.0-p) * <a class="code" href="group__R__style__distribution.html#ga5eb914782c488bd3ec4a50d4e4a73394">dnorm</a>(x, Type(0), sigma(1), <span class="keyword">false</span>) ) );</div></div><!-- fragment --><h3>Time series</h3>
<p>Autoregressive (AR) processes may be implemented using the compact notation of section <a href="#Densities">Densities</a>. The resulting AR process may be applied both in the observational part and in the distribution of a latent variable.</p>
<p>Nonlinear time must be implemented from scratch, as in the example <a class="el" href="thetalog_8cpp-example.html">thetalog.cpp</a></p>
<h3>Spatial models</h3>
<p>TMB has strong support for spatial model and space-time models via the <code><a class="el" href="namespacedensity.html#a3aee006c3c4f4ef0b0c3d4628ead67d0" title="Construct object to evaluate density of Gaussian Markov Random Field (GMRF) for sparse Q...">GMRF()</a></code> and <code><a class="el" href="namespacedensity.html#a7163798c4b0467ac2e570b034d7ca4c5" title="Construct object to evaluate the separable extension of two multivariate zero-mean normal densities...">SEPARABLE()</a></code> functions, and the notion of a <code>distribution</code>. The reader is referred to section <a href="#Densities">Densities</a> for details and examples.</p>
<h1><a class="anchor" id="CppTutorial"></a>
C++ tutorial </h1>
<h3>I know R but not C++</h3>
<p>Summary of how syntax differs between R and C++:</p>
<div class="fragment"><div class="line">              R code             C++/TMB code</div><div class="line"></div><div class="line">Comments      #                  <span class="comment">//                          // Comment symbol</span></div><div class="line">Constants     3.4                Type(3.4);                  <span class="comment">// Explicit casting recommended in TMB</span></div><div class="line">Scalar        x = 5.2            Type x = Type(5.2);         <span class="comment">// Variables must have type</span></div><div class="line">Arrays        x = numeric(10)    <a class="code" href="structvector.html">vector</a>&lt;Type&gt; x(10);         <span class="comment">// C++ code here does NOT initialize to 0</span></div><div class="line">Indexing      x[1]+x[10]         x(0)+x(9);                  <span class="comment">// C++ indexing is zero-based</span></div><div class="line">Loops         for(i in 1:10)     for(<span class="keywordtype">int</span> i=1;i&lt;=10;i++)      <span class="comment">// Integer i must be declared in C++</span></div><div class="line">Increments    x[1] = x[1] + 3    x(0) += 3.0;                <span class="comment">// += -= *= /= incremental operators in C++</span></div></div><!-- fragment --><p>It is important to note the following difference compared to R:</p>
<blockquote class="doxtable">
<p>Vectors, matrices and arrays are <b>not</b> zero-initialized in C++. </p>
</blockquote>
<p>A zero initialized object is created using Eigens <code>setZero()</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structmatrix.html">matrix&lt;Type&gt;</a> m(4,5);</div><div class="line">m.setZero();</div></div><!-- fragment --><h3>I know C++</h3>
<p>TMB specific C++ include:</p><ul>
<li>You should not use <code>if(x)</code> statements where <code>x</code> is a <code>PARAMETER</code>, or is derived from a variable of type <code>PARAMETER</code>. (It is OK to use <code>if</code> on <code>DATA</code> types, however.) TMB will remove the <code>if(x)</code> statement, so the code will produce unexpected results. </li>
</ul>
</div></div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
