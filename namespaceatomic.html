<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: atomic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atomic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace with special functions and derivatives.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1AtomicGlobal.html">AtomicGlobal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For backwards compatibility with CppAD.  <a href="structatomic_1_1AtomicGlobal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1AtomicLocal.html">AtomicLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface to checkpointing using <a class="el" href="namespaceTMBad.html" title="Automatic differentiation library designed for TMB. ">TMBad</a>.  <a href="structatomic_1_1AtomicLocal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67c15c0dfea98b3f79f7f0660e2abe95"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a67c15c0dfea98b3f79f7f0660e2abe95"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a67c15c0dfea98b3f79f7f0660e2abe95">bessel_i_10</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a67c15c0dfea98b3f79f7f0660e2abe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of \(besselI(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\).  <a href="#a67c15c0dfea98b3f79f7f0660e2abe95">More...</a><br /></td></tr>
<tr class="separator:a67c15c0dfea98b3f79f7f0660e2abe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad076f1600730946b58fdcd239cc25b61"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ad076f1600730946b58fdcd239cc25b61"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ad076f1600730946b58fdcd239cc25b61">bessel_k_10</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ad076f1600730946b58fdcd239cc25b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of \(besselK(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\).  <a href="#ad076f1600730946b58fdcd239cc25b61">More...</a><br /></td></tr>
<tr class="separator:ad076f1600730946b58fdcd239cc25b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ab86d10e39e1b3aebc1fbd26aa26346d4">D_incpl_gamma_shape</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p><p class="formulaDsp">
\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]
</p>
<p> where the 4 input parameters are passed as a vector \(x=(y,\lambda,n,c)\). Note that the normalized incomplete gamma function is obtained as the special case \(n=0\) and \(c=-\log \Gamma(\lambda)\). Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}\).  <a href="#ab86d10e39e1b3aebc1fbd26aa26346d4">More...</a><br /></td></tr>
<tr class="separator:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a3b1fbc500a01972017dabccfbcd6ebc1">D_lgamma</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of the n'th order derivative of the log gamma function. </p><p class="formulaDsp">
\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]
</p>
<p> where the 2 input parameters are passed as a vector \(x=(\lambda,n)\). The special case \(n=0\) gives the log gamma function.  <a href="#a3b1fbc500a01972017dabccfbcd6ebc1">More...</a><br /></td></tr>
<tr class="separator:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gac09966696ad9685dc8047d6c582bc0ae">expm</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gac09966696ad9685dc8047d6c582bc0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="group__matrix__functions.html#gac09966696ad9685dc8047d6c582bc0ae">More...</a><br /></td></tr>
<tr class="separator:gac09966696ad9685dc8047d6c582bc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d87d7ad84cedf1ac6460de525a4dbc1"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga8d87d7ad84cedf1ac6460de525a4dbc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvector.html">vector</a>&lt; std::complex&lt; Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga8d87d7ad84cedf1ac6460de525a4dbc1">fft</a> (<a class="el" href="structvector.html">vector</a>&lt; std::complex&lt; Type &gt; &gt; xc, bool inverse=false)</td></tr>
<tr class="memdesc:ga8d87d7ad84cedf1ac6460de525a4dbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">FFT (unscaled)  <a href="group__matrix__functions.html#ga8d87d7ad84cedf1ac6460de525a4dbc1">More...</a><br /></td></tr>
<tr class="separator:ga8d87d7ad84cedf1ac6460de525a4dbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6bfb1722819752d1ad1084a6de6f27"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aca6bfb1722819752d1ad1084a6de6f27"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#aca6bfb1722819752d1ad1084a6de6f27">inv_incpl_gamma</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:aca6bfb1722819752d1ad1084a6de6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of inverse of scaled incomplete gamma function. Given \(z\) find \(y\) such that </p><p class="formulaDsp">
\[ z = \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \:dt \]
</p>
<p> where the 3 input parameters are passed as a vector \(x=(z,\lambda,c)\). The special case \(c=-\log \Gamma(\lambda)\) gives the inverse normalized incomplete gamma function. Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{R}\).  <a href="#aca6bfb1722819752d1ad1084a6de6f27">More...</a><br /></td></tr>
<tr class="separator:aca6bfb1722819752d1ad1084a6de6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dc81e22f17e8319ad028d01840e048"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a60dc81e22f17e8319ad028d01840e048"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a60dc81e22f17e8319ad028d01840e048">invpd</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a60dc81e22f17e8319ad028d01840e048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of log determinant <em>and</em> inverse of positive definite n-by-n matrix. Calculated by Cholesky decomposition.  <a href="#a60dc81e22f17e8319ad028d01840e048">More...</a><br /></td></tr>
<tr class="separator:a60dc81e22f17e8319ad028d01840e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#af7937bd97f9d5a2e80c00d03faf3a7c2">logdet</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of log determinant of positive definite n-by-n matrix.  <a href="#af7937bd97f9d5a2e80c00d03faf3a7c2">More...</a><br /></td></tr>
<tr class="separator:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5555ee5c905915a566d47d7f2830424"><td class="memTemplParams" colspan="2">
template&lt;class Type &gt; </td></tr>
<tr class="memitem:gae5555ee5c905915a566d47d7f2830424"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gae5555ee5c905915a566d47d7f2830424">logdet</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gae5555ee5c905915a566d47d7f2830424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log-determinant of positive definite matrix. <br /></td></tr>
<tr class="separator:gae5555ee5c905915a566d47d7f2830424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991f5af63e94ad38f54c99a81823efc"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a4991f5af63e94ad38f54c99a81823efc"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a4991f5af63e94ad38f54c99a81823efc">matinv</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a4991f5af63e94ad38f54c99a81823efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of matrix inversion. Inverts n-by-n matrix by LU-decomposition.  <a href="#a4991f5af63e94ad38f54c99a81823efc">More...</a><br /></td></tr>
<tr class="separator:a4991f5af63e94ad38f54c99a81823efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inverse.  <a href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">More...</a><br /></td></tr>
<tr class="separator:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06aed041873dea3426da0d0bac628583"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga06aed041873dea3426da0d0bac628583"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga06aed041873dea3426da0d0bac628583">matinvpd</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, Type &amp;<a class="el" href="namespaceatomic.html#af7937bd97f9d5a2e80c00d03faf3a7c2">logdet</a>)</td></tr>
<tr class="memdesc:ga06aed041873dea3426da0d0bac628583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inverse and determinant.  <a href="group__matrix__functions.html#ga06aed041873dea3426da0d0bac628583">More...</a><br /></td></tr>
<tr class="separator:ga06aed041873dea3426da0d0bac628583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a1ea1a599dfa8b5b10af52c40be19210e">matmul</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a1ea1a599dfa8b5b10af52c40be19210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix.  <a href="#a1ea1a599dfa8b5b10af52c40be19210e">More...</a><br /></td></tr>
<tr class="separator:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481538cdd18f419396ee65eaec62c0ba"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga481538cdd18f419396ee65eaec62c0ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; y)</td></tr>
<tr class="memdesc:ga481538cdd18f419396ee65eaec62c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply.  <a href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">More...</a><br /></td></tr>
<tr class="separator:ga481538cdd18f419396ee65eaec62c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501e991d939deb58f6455904262be81"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ae501e991d939deb58f6455904262be81"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ae501e991d939deb58f6455904262be81">pnorm1</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ae501e991d939deb58f6455904262be81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'.  <a href="#ae501e991d939deb58f6455904262be81">More...</a><br /></td></tr>
<tr class="separator:ae501e991d939deb58f6455904262be81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a29ad7d7fdc9702c597b6d76d3ef281e3">ppois</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of poisson cdf \(ppois(n,\lambda)\). Valid parameter range: \(x =(n,\lambda) \in \mathbb{N}_0\times\mathbb{R}_+\).  <a href="#a29ad7d7fdc9702c597b6d76d3ef281e3">More...</a><br /></td></tr>
<tr class="separator:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a6bb7b5e1dbb5ed751e3320b3f07bef77">qnorm1</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of standard normal quantile function. Derivative is expressed through 'dnorm1'.  <a href="#a6bb7b5e1dbb5ed751e3320b3f07bef77">More...</a><br /></td></tr>
<tr class="separator:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75943a50af77397c002b5d414de0e5d6"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga75943a50af77397c002b5d414de0e5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga75943a50af77397c002b5d414de0e5d6">sqrtm</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ga75943a50af77397c002b5d414de0e5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix square root.  <a href="group__matrix__functions.html#ga75943a50af77397c002b5d414de0e5d6">More...</a><br /></td></tr>
<tr class="separator:ga75943a50af77397c002b5d414de0e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace with special functions and derivatives. </p>
<p>This namespace extends the 'derivatives table' of CppAD.</p><ul>
<li>R's special math library is extended with derivatives in cases where symbolic derivatives are available. These special functions are often iterative and therefore difficult to implement with AD types. Instead, we code the derivatives based on the double versions available from R. This approach requires fewer code lines, and has the benefit of obtaining the same high accuracy as R's math functions.</li>
<li>Some matrix operations are extended with derivatives. This greatly reduces the AD memory usage. Furthermore, these atomic operations can be linked to a performance library by setting preprocesor flag EIGEN_USE_BLAS.</li>
<li>New symbols can be added by advanced users. First option is to code the reverse mode derivatives by hand using the TMB_ATOMIC_VECTOR_FUNCTION macro, see source code for examples. Second option is to generate reverse mode derivatives automatically using the macro REGISTER_ATOMIC. </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a67c15c0dfea98b3f79f7f0660e2abe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c15c0dfea98b3f79f7f0660e2abe95">&sect;&nbsp;</a></span>bessel_i_10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::bessel_i_10 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of \(besselI(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\). </p>
<dl class="section note"><dt>Note</dt><dd>This atomic function does not handle the derivative wrt. \(\nu\). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="ad076f1600730946b58fdcd239cc25b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad076f1600730946b58fdcd239cc25b61">&sect;&nbsp;</a></span>bessel_k_10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::bessel_k_10 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of \(besselK(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\). </p>
<dl class="section note"><dt>Note</dt><dd>This atomic function does not handle the derivative wrt. \(\nu\). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="ab86d10e39e1b3aebc1fbd26aa26346d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86d10e39e1b3aebc1fbd26aa26346d4">&sect;&nbsp;</a></span>D_incpl_gamma_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::D_incpl_gamma_shape </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p><p class="formulaDsp">
\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]
</p>
<p> where the 4 input parameters are passed as a vector \(x=(y,\lambda,n,c)\). Note that the normalized incomplete gamma function is obtained as the special case \(n=0\) and \(c=-\log \Gamma(\lambda)\). Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}\). </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a3b1fbc500a01972017dabccfbcd6ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1fbc500a01972017dabccfbcd6ebc1">&sect;&nbsp;</a></span>D_lgamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::D_lgamma </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of the n'th order derivative of the log gamma function. </p><p class="formulaDsp">
\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]
</p>
<p> where the 2 input parameters are passed as a vector \(x=(\lambda,n)\). The special case \(n=0\) gives the log gamma function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="aca6bfb1722819752d1ad1084a6de6f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6bfb1722819752d1ad1084a6de6f27">&sect;&nbsp;</a></span>inv_incpl_gamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::inv_incpl_gamma </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of inverse of scaled incomplete gamma function. Given \(z\) find \(y\) such that </p><p class="formulaDsp">
\[ z = \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \:dt \]
</p>
<p> where the 3 input parameters are passed as a vector \(x=(z,\lambda,c)\). The special case \(c=-\log \Gamma(\lambda)\) gives the inverse normalized incomplete gamma function. Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{R}\). </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a60dc81e22f17e8319ad028d01840e048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dc81e22f17e8319ad028d01840e048">&sect;&nbsp;</a></span>invpd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::invpd </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of log determinant <em>and</em> inverse of positive definite n-by-n matrix. Calculated by Cholesky decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1+n*n. </dd></dl>

</div>
</div>
<a id="af7937bd97f9d5a2e80c00d03faf3a7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7937bd97f9d5a2e80c00d03faf3a7c2">&sect;&nbsp;</a></span>logdet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::logdet </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of log determinant of positive definite n-by-n matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="laplace_8cpp-example.html#a5">laplace.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a4991f5af63e94ad38f54c99a81823efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4991f5af63e94ad38f54c99a81823efc">&sect;&nbsp;</a></span>matinv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::matinv </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of matrix inversion. Inverts n-by-n matrix by LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n*n. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="laplace_8cpp-example.html#a4">laplace.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="structnewton_1_1jacobian__sparse__plus__lowrank__t.html#a8acd11aa174d7cc9ee8a89e8aa847fcf">newton::jacobian_sparse_plus_lowrank_t&lt; dummy &gt;::llt_solve()</a>, and <a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv()</a>.</p>

</div>
</div>
<a id="a1ea1a599dfa8b5b10af52c40be19210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea1a599dfa8b5b10af52c40be19210e">&sect;&nbsp;</a></span>matmul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::matmul </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2+n1*n2+n2*n3 containing the output dimension (length=2), the first matrix (length=n1*n2) and the second matrix (length=n2*n3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n1*n3 containing result of matrix multiplication. </dd></dl>

<p>Referenced by <a class="el" href="structnewton_1_1jacobian__sparse__plus__lowrank__t.html#a8acd11aa174d7cc9ee8a89e8aa847fcf">newton::jacobian_sparse_plus_lowrank_t&lt; dummy &gt;::llt_solve()</a>, and <a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul()</a>.</p>

</div>
</div>
<a id="ae501e991d939deb58f6455904262be81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae501e991d939deb58f6455904262be81">&sect;&nbsp;</a></span>pnorm1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::pnorm1 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a29ad7d7fdc9702c597b6d76d3ef281e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ad7d7fdc9702c597b6d76d3ef281e3">&sect;&nbsp;</a></span>ppois()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::ppois </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of poisson cdf \(ppois(n,\lambda)\). Valid parameter range: \(x =(n,\lambda) \in \mathbb{N}_0\times\mathbb{R}_+\). </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a6bb7b5e1dbb5ed751e3320b3f07bef77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb7b5e1dbb5ed751e3320b3f07bef77">&sect;&nbsp;</a></span>qnorm1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::qnorm1 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of standard normal quantile function. Derivative is expressed through 'dnorm1'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
