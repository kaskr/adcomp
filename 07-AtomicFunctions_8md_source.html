<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: 07-AtomicFunctions.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">07-AtomicFunctions.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Atomic functions {#AtomicFunctions}</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;================</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Custom functions and derivatives can be added to the TMB library. This may be necessary for the following reasons:</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;* Adaptive (e.g. iterative) algorithms cannot be represented by a fixed computational graph and thus cannot be directly differentiated using TMB. Algorithms that use parameter dependent if-else branching are examples of such functions.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;* Some functions have so many floating point operations that it is infeasible to expand the computational graph. Memory usage may be greatly reduced in such cases by collapsing the computational graph to a singe node with multiple inputs and outputs.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## Reverse mode differentiation</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;TMB uses CppAD as its engine for reverse mode derivatives. In order to add a new primitive function</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;\f[f: R^n \rightarrow R^m\f]</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;we must inform CppAD how to calculate derivatives of this function in reverse mode. That is, for any range space vector \f$w \in R^m\f$ we must calculate the gradient of the function \f$R^n \rightarrow R\f$ given by</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;\f[ x \rightarrow \text{sum}( f(x) \odot w ) \f]</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;where &#39;$\odot$&#39; is pointwise multiplication.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;## Example: Adding new primitive function with known derivatives</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;As an example consider the [Lambert W function](https://en.wikipedia.org/wiki/Lambert_W_function) defined implicitly by</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;\f[y = W(y e^y)\f]</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Here, we only consider \f$W\f$ as defined on the positive reals. It follows, by differentiating the above identity, that</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;\f[ W&#39;(x) = \frac{1}{ \exp\left(W(x)\right) \left(1 + W(x)\right) } \f]</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;When coding reverse-mode derivatives we can assume that the function value \f$W(x)\f$ has already been computed during a forward pass. For efficiency reasons we should use this intermediate calculation rather than re-calculating \f$W(x)\f$ in the reverse pass.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;We&#39;ll assume that a plain C++ function (taking double types as input/output) is available to calculate \f$W(x)\f$. It doesn&#39;t matter whether you have the source code of an implementation or just the header with linkage to an external library:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;```{cpp}</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;double LambertW(double x);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;```</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;The macro `TMB_ATOMIC_VECTOR_FUNCTION()` is used to declare our new primitive Lambert \f$W\f$ function:</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;```{cpp}</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;TMB_ATOMIC_VECTOR_FUNCTION(</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    // ATOMIC_NAME</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    LambertW</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    ,</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    // OUTPUT_DIM</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    1,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    // ATOMIC_DOUBLE</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    ty[0] = LambertW(tx[0]); // Call the &#39;double&#39; version</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    ,</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    // ATOMIC_REVERSE</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    Type W  = ty[0];                    // Function value from forward pass</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    Type DW = 1. / (exp(W) * (1. + W)); // Derivative</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    px[0] = DW * py[0];                 // Reverse mode chain rule</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;)</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;```</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;Let&#39;s explain in detail what is going on. The macro takes four arguments:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;1. `ATOMIC_NAME`: Name of new primitive function taking `CppAD::vector` as input and output.</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;2. `OUTPUT_DIM`: Dimension of the `CppAD::vector` which is the function output.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;3. `ATOMIC_DOUBLE`: Specifies how to evaluate the primitive function for the ordinary double type. `tx` denotes the input vector and `ty` the output vector of the function \f$f: R^n \rightarrow R^m\f$. In this case both have dimension one.</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;4. `ATOMIC_REVERSE`: How to calculate the reverse mode derivatives for a general `Type`. Again `tx` and `ty` denote function input and output but now `ty` has been computed and is available as an intermediate value. The vectors `px` and `py` denote partial derivatives of the end result with respect to \f$x\f$ and \f$y\f$ respectively. `py` is given and we must calculate `px` using the chain rule. This first order derivative rule is automatically expanded up to higher orders required when using TMB&#39;s random effects calculations.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;To make the function work like other TMB functions it is convenient to define scalar and a vectorized versions that call the atomic function:</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;```{cpp}</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;// Scalar version</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;template&lt;class Type&gt;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;Type LambertW(Type x){</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  CppAD::vector&lt;Type&gt; tx(1);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  tx[0] = x;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  return LambertW(tx)[0];</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;// Vectorized version</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;VECTORIZE_1t(LambertW)</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;```</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;### Testing the primitive function</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;Here is a complete example using Newton&#39;s method to calculate the Lambert \f$W\f$ function</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;(there are more sophisticated algorithms such as the one by [Fukushima (2013)](https://doi.org/10.1016/j.cam.2012.11.021),</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;but that doesn&#39;t matter for this example):</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;```{cpp}</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;#include &lt;TMB.hpp&gt;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;// Double version of Lambert W function</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;double LambertW(double x) {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  double logx = log(x);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  double y = (logx &gt; 0 ? logx : 0);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  int niter = 100, i=0;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  for (; i &lt; niter; i++) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    if ( fabs( logx - log(y) - y) &lt; 1e-9) break;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    y -= (y - exp(logx - y)) / (1 + y);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  }</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  if (i == niter) Rf_warning(&quot;W: failed convergence&quot;);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  return y;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;}</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;TMB_ATOMIC_VECTOR_FUNCTION(</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    // ATOMIC_NAME</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    LambertW</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    ,</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    // OUTPUT_DIM</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    1,</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    // ATOMIC_DOUBLE</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    ty[0] = LambertW(tx[0]); // Call the &#39;double&#39; version</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    ,</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    // ATOMIC_REVERSE</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    Type W  = ty[0];                    // Function value from forward pass</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    Type DW = 1. / (exp(W) * (1. + W)); // Derivative</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    px[0] = DW * py[0];                 // Reverse mode chain rule</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;// Scalar version</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;template&lt;class Type&gt;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;Type LambertW(Type x){</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  CppAD::vector&lt;Type&gt; tx(1);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  tx[0] = x;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  return LambertW(tx)[0];</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;// Vectorized version</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;VECTORIZE1_t(LambertW)</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;template&lt;class Type&gt;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;Type objective_function&lt;Type&gt;::operator() ()</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;{</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  PARAMETER_VECTOR(x);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  Type f = LambertW(x).sum();</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  return f;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;```</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;And from R</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;```r</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;compile(&quot;lambert.cpp&quot;)</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;dyn.load(dynlib(&quot;lambert&quot;))</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;```</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;#### Checking function value and derivatives</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;Check definition of the function:</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;```r</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;obj &lt;- MakeADFun(data=list(), parameters=list(x=1), DLL=&quot;lambert&quot;)</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;obj$fn(7 * exp(7))</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;```</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;## [1] 7</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;```</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;Check derivatives using the `numDeriv` package:</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;```r</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;numDeriv::grad(obj$fn, 7)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;```</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;```</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;## [1] 0.08626538</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;```</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;```r</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;obj$gr(7)</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;```</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;```</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;##            [,1]</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;## [1,] 0.08626538</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;```</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;Also try second order derivatives:</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;```r</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;numDeriv::hessian(obj$fn, 7)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;```</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;```</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;##             [,1]</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;## [1,] -0.01038959</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;```</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;```r</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;obj$he(7)</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;```</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;```</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;##             [,1]</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;## [1,] -0.01038969</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;```</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;## Other approaches</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;For the Lambert \f$W\f$ function we know how to calculate the derivatives. There are cases for which the derivatives are impossible (or difficult) to write down. If you&#39;re in this situation you may want to try using forward mode AD to help in defining an atomic function. A full worked out example is available here: \ref adaptive_integration.cpp. Derivatives are calculated automatically and if-else branching is allowed. The main downside with this approach is that it is limited to functions with very few inputs.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;Checkpointing is another useful technique. It is demonstrated in the example \ref register_atomic.cpp. It does not work for adaptive algorithms but is otherwise automatic. It is useful to reduce AD memory usage in cases where the same sequence of operations is being applied many times.</div></div><!-- fragment --></div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
