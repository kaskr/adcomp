<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: TMBad::global::OperatorPure Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTMBad.html">TMBad</a></li><li class="navelem"><a class="el" href="structTMBad_1_1global.html">global</a></li><li class="navelem"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structTMBad_1_1global_1_1OperatorPure-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TMBad::global::OperatorPure Struct Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract operator for the operation stack <code><a class="el" href="structTMBad_1_1global.html#ac67f7cc38f0893edccbfd5a603536685" title="Operation stack. ">global::opstack</a></code>  
 <a href="structTMBad_1_1global_1_1OperatorPure.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="global_8hpp_source.html">global.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a1ba345e1da9bd94ebacf8c6228175c"><td class="memItemLeft" align="right" valign="top"><a id="a9a1ba345e1da9bd94ebacf8c6228175c"></a>
virtual <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9a1ba345e1da9bd94ebacf8c6228175c">copy</a> ()=0</td></tr>
<tr class="memdesc:a9a1ba345e1da9bd94ebacf8c6228175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:a9a1ba345e1da9bd94ebacf8c6228175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce53d5b047280df4621738b5e1833a"><td class="memItemLeft" align="right" valign="top"><a id="ae2ce53d5b047280df4621738b5e1833a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ae2ce53d5b047280df4621738b5e1833a">deallocate</a> ()=0</td></tr>
<tr class="memdesc:ae2ce53d5b047280df4621738b5e1833a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:ae2ce53d5b047280df4621738b5e1833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf920a9ec8270222dbb960c4567465"><td class="memItemLeft" align="right" valign="top"><a id="a9dbf920a9ec8270222dbb960c4567465"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465">decrement</a> (IndexPair &amp;ptr)=0</td></tr>
<tr class="memdesc:a9dbf920a9ec8270222dbb960c4567465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement input/output pointers to prepare for the previous <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a> in the stack. <br /></td></tr>
<tr class="separator:a9dbf920a9ec8270222dbb960c4567465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebeb799cadd483b2305b0bec3b7c810"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a2ebeb799cadd483b2305b0bec3b7c810">dependencies</a> (<a class="el" href="structTMBad_1_1Args.html">Args</a>&lt;&gt; &amp;args, Dependencies &amp;dep)=0</td></tr>
<tr class="memdesc:a2ebeb799cadd483b2305b0bec3b7c810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of variables required by this operator.  <a href="#a2ebeb799cadd483b2305b0bec3b7c810">More...</a><br /></td></tr>
<tr class="separator:a2ebeb799cadd483b2305b0bec3b7c810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52c4ff3af471f601fc9d82591a3f68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a2d52c4ff3af471f601fc9d82591a3f68">dependencies_updating</a> (<a class="el" href="structTMBad_1_1Args.html">Args</a>&lt;&gt; &amp;args, Dependencies &amp;dep)=0</td></tr>
<tr class="memdesc:a2d52c4ff3af471f601fc9d82591a3f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of variables updated by this operator.  <a href="#a2d52c4ff3af471f601fc9d82591a3f68">More...</a><br /></td></tr>
<tr class="separator:a2d52c4ff3af471f601fc9d82591a3f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5f99dd4f7776763c45ca590719197b"><td class="memItemLeft" align="right" valign="top"><a id="afe5f99dd4f7776763c45ca590719197b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b">forward</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Scalar &gt; &amp;args)=0</td></tr>
<tr class="memdesc:afe5f99dd4f7776763c45ca590719197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update output values of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:afe5f99dd4f7776763c45ca590719197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01e0291993b4c08cc1311bada7ab39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#aca01e0291993b4c08cc1311bada7ab39">forward</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; bool &gt; &amp;args)=0</td></tr>
<tr class="memdesc:aca01e0291993b4c08cc1311bada7ab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark forward dependencies.  <a href="#aca01e0291993b4c08cc1311bada7ab39">More...</a><br /></td></tr>
<tr class="separator:aca01e0291993b4c08cc1311bada7ab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad50faaa3b28e37ba37555fac7ac844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9ad50faaa3b28e37ba37555fac7ac844">forward</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Replay &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a9ad50faaa3b28e37ba37555fac7ac844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay operation sequence.  <a href="#a9ad50faaa3b28e37ba37555fac7ac844">More...</a><br /></td></tr>
<tr class="separator:a9ad50faaa3b28e37ba37555fac7ac844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad5f0d6bc1ec1c9e8218c5de2ab4468"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#abad5f0d6bc1ec1c9e8218c5de2ab4468">forward</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Writer &gt; &amp;args)=0</td></tr>
<tr class="memdesc:abad5f0d6bc1ec1c9e8218c5de2ab4468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source code writer.  <a href="#abad5f0d6bc1ec1c9e8218c5de2ab4468">More...</a><br /></td></tr>
<tr class="separator:abad5f0d6bc1ec1c9e8218c5de2ab4468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9de911fe7f48f7b34d4b47cde73d1ea"><td class="memItemLeft" align="right" valign="top"><a id="ab9de911fe7f48f7b34d4b47cde73d1ea"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ab9de911fe7f48f7b34d4b47cde73d1ea">forward_incr</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Scalar &gt; &amp;args)=0</td></tr>
<tr class="memdesc:ab9de911fe7f48f7b34d4b47cde73d1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b" title="Update output values of this OperatorPure. ">forward()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737" title="Increment input/output pointers to prepare for the next OperatorPure in the stack. ">increment()</a></code> <br /></td></tr>
<tr class="separator:ab9de911fe7f48f7b34d4b47cde73d1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2c25c615cb04d648a86e1825724891"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#aef2c25c615cb04d648a86e1825724891">forward_incr</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; bool &gt; &amp;args)=0</td></tr>
<tr class="memdesc:aef2c25c615cb04d648a86e1825724891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b" title="Update output values of this OperatorPure. ">forward()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737" title="Increment input/output pointers to prepare for the next OperatorPure in the stack. ">increment()</a></code>  <a href="#aef2c25c615cb04d648a86e1825724891">More...</a><br /></td></tr>
<tr class="separator:aef2c25c615cb04d648a86e1825724891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac7989da0024e46399c68c1ec0973ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a6ac7989da0024e46399c68c1ec0973ad">forward_incr</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Replay &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a6ac7989da0024e46399c68c1ec0973ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay operation sequence.  <a href="#a6ac7989da0024e46399c68c1ec0973ad">More...</a><br /></td></tr>
<tr class="separator:a6ac7989da0024e46399c68c1ec0973ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4646bc7cfcb7ba3663da1f079c486f46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a4646bc7cfcb7ba3663da1f079c486f46">forward_incr</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Writer &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a4646bc7cfcb7ba3663da1f079c486f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source code writer.  <a href="#a4646bc7cfcb7ba3663da1f079c486f46">More...</a><br /></td></tr>
<tr class="separator:a4646bc7cfcb7ba3663da1f079c486f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c2314567f36612ffde870381408bc5"><td class="memItemLeft" align="right" valign="top"><a id="a49c2314567f36612ffde870381408bc5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a49c2314567f36612ffde870381408bc5">forward_incr_mark_dense</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; bool &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a49c2314567f36612ffde870381408bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally mark <em>all</em> outputs. <br /></td></tr>
<tr class="separator:a49c2314567f36612ffde870381408bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112474b01b04462a0819883905824932"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a112474b01b04462a0819883905824932">identifier</a> ()=0</td></tr>
<tr class="memdesc:a112474b01b04462a0819883905824932"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> identifier.  <a href="#a112474b01b04462a0819883905824932">More...</a><br /></td></tr>
<tr class="separator:a112474b01b04462a0819883905824932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7d39b97134ff35fe310c03634c7189"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a2e7d39b97134ff35fe310c03634c7189">incomplete</a> ()=0</td></tr>
<tr class="memdesc:a2e7d39b97134ff35fe310c03634c7189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to operator before it was completed.  <a href="#a2e7d39b97134ff35fe310c03634c7189">More...</a><br /></td></tr>
<tr class="separator:a2e7d39b97134ff35fe310c03634c7189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843683185bebb0e7abfb6fe39d82f737"><td class="memItemLeft" align="right" valign="top"><a id="a843683185bebb0e7abfb6fe39d82f737"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737">increment</a> (IndexPair &amp;ptr)=0</td></tr>
<tr class="memdesc:a843683185bebb0e7abfb6fe39d82f737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment input/output pointers to prepare for the next <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a> in the stack. <br /></td></tr>
<tr class="separator:a843683185bebb0e7abfb6fe39d82f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daa17e4ebeb64403865a4320cf4bb91"><td class="memItemLeft" align="right" valign="top"><a id="a4daa17e4ebeb64403865a4320cf4bb91"></a>
virtual <a class="el" href="structTMBad_1_1op__info.html">op_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a4daa17e4ebeb64403865a4320cf4bb91">info</a> ()=0</td></tr>
<tr class="memdesc:a4daa17e4ebeb64403865a4320cf4bb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get operator info. <br /></td></tr>
<tr class="separator:a4daa17e4ebeb64403865a4320cf4bb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e96537422a8f7a6fd69ba3d8a926a1d"><td class="memItemLeft" align="right" valign="top"><a id="a2e96537422a8f7a6fd69ba3d8a926a1d"></a>
virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a2e96537422a8f7a6fd69ba3d8a926a1d">input_size</a> ()=0</td></tr>
<tr class="memdesc:a2e96537422a8f7a6fd69ba3d8a926a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of inputs to this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:a2e96537422a8f7a6fd69ba3d8a926a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bfebf8f84888138185c39df3de43d7"><td class="memItemLeft" align="right" valign="top"><a id="a92bfebf8f84888138185c39df3de43d7"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a92bfebf8f84888138185c39df3de43d7">op_name</a> ()</td></tr>
<tr class="memdesc:a92bfebf8f84888138185c39df3de43d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:a92bfebf8f84888138185c39df3de43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98a03b95e9488eaf0d5a0c7fc6380d"><td class="memItemLeft" align="right" valign="top"><a id="abf98a03b95e9488eaf0d5a0c7fc6380d"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#abf98a03b95e9488eaf0d5a0c7fc6380d">operator_data</a> ()=0</td></tr>
<tr class="memdesc:abf98a03b95e9488eaf0d5a0c7fc6380d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional operator_data. <br /></td></tr>
<tr class="separator:abf98a03b95e9488eaf0d5a0c7fc6380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1909d3da095674e961fb1245a21fa2d"><td class="memItemLeft" align="right" valign="top"><a id="af1909d3da095674e961fb1245a21fa2d"></a>
virtual <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#af1909d3da095674e961fb1245a21fa2d">other_fuse</a> (<a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *other)=0</td></tr>
<tr class="memdesc:af1909d3da095674e961fb1245a21fa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for operator fusion. Merge this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a> with another operator. If no match return NULL. <br /></td></tr>
<tr class="separator:af1909d3da095674e961fb1245a21fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a747e50a32a849cd403c4332abbf20"><td class="memItemLeft" align="right" valign="top"><a id="ac9a747e50a32a849cd403c4332abbf20"></a>
virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ac9a747e50a32a849cd403c4332abbf20">output_size</a> ()=0</td></tr>
<tr class="memdesc:ac9a747e50a32a849cd403c4332abbf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of outputs from this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:ac9a747e50a32a849cd403c4332abbf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5466d15800ff5168642d249d314a0ff7"><td class="memItemLeft" align="right" valign="top"><a id="a5466d15800ff5168642d249d314a0ff7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a5466d15800ff5168642d249d314a0ff7">print</a> (<a class="el" href="structTMBad_1_1global_1_1print__config.html">print_config</a> cfg)=0</td></tr>
<tr class="memdesc:a5466d15800ff5168642d249d314a0ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional print method. <br /></td></tr>
<tr class="separator:a5466d15800ff5168642d249d314a0ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121f1f604268a28a3afd664d04bbe658"><td class="memItemLeft" align="right" valign="top"><a id="a121f1f604268a28a3afd664d04bbe658"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658">reverse</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Scalar &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a121f1f604268a28a3afd664d04bbe658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input derivs of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>. <br /></td></tr>
<tr class="separator:a121f1f604268a28a3afd664d04bbe658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac0148046a58730801cd66afe201fee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a5ac0148046a58730801cd66afe201fee">reverse</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; bool &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a5ac0148046a58730801cd66afe201fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark reverse dependencies.  <a href="#a5ac0148046a58730801cd66afe201fee">More...</a><br /></td></tr>
<tr class="separator:a5ac0148046a58730801cd66afe201fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e47c64e0c1b4097ed2b5d0f2d7388e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ab6e47c64e0c1b4097ed2b5d0f2d7388e">reverse</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Replay &gt; &amp;args)=0</td></tr>
<tr class="memdesc:ab6e47c64e0c1b4097ed2b5d0f2d7388e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay operation sequence.  <a href="#ab6e47c64e0c1b4097ed2b5d0f2d7388e">More...</a><br /></td></tr>
<tr class="separator:ab6e47c64e0c1b4097ed2b5d0f2d7388e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8204f094377b82cf5db000b4b2896fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ac8204f094377b82cf5db000b4b2896fd">reverse</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Writer &gt; &amp;args)=0</td></tr>
<tr class="memdesc:ac8204f094377b82cf5db000b4b2896fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source code writer.  <a href="#ac8204f094377b82cf5db000b4b2896fd">More...</a><br /></td></tr>
<tr class="separator:ac8204f094377b82cf5db000b4b2896fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e953543dd3d2ea1d89f45939f239226"><td class="memItemLeft" align="right" valign="top"><a id="a1e953543dd3d2ea1d89f45939f239226"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a1e953543dd3d2ea1d89f45939f239226">reverse_decr</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Scalar &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a1e953543dd3d2ea1d89f45939f239226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465" title="Decrement input/output pointers to prepare for the previous OperatorPure in the stack. ">decrement()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658" title="Update input derivs of this OperatorPure. ">reverse()</a></code> <br /></td></tr>
<tr class="separator:a1e953543dd3d2ea1d89f45939f239226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5486ac653339fb30a3f76a4d150536"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9c5486ac653339fb30a3f76a4d150536">reverse_decr</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; bool &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a9c5486ac653339fb30a3f76a4d150536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465" title="Decrement input/output pointers to prepare for the previous OperatorPure in the stack. ">decrement()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658" title="Update input derivs of this OperatorPure. ">reverse()</a></code>  <a href="#a9c5486ac653339fb30a3f76a4d150536">More...</a><br /></td></tr>
<tr class="separator:a9c5486ac653339fb30a3f76a4d150536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aacea34cbf8c56e1d2d1e639b9b3c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a64aacea34cbf8c56e1d2d1e639b9b3c2">reverse_decr</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Replay &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a64aacea34cbf8c56e1d2d1e639b9b3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay operation sequence.  <a href="#a64aacea34cbf8c56e1d2d1e639b9b3c2">More...</a><br /></td></tr>
<tr class="separator:a64aacea34cbf8c56e1d2d1e639b9b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69eefd0ab8ef5ec77054e20b47c6334"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#ad69eefd0ab8ef5ec77054e20b47c6334">reverse_decr</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Writer &gt; &amp;args)=0</td></tr>
<tr class="memdesc:ad69eefd0ab8ef5ec77054e20b47c6334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source code writer.  <a href="#ad69eefd0ab8ef5ec77054e20b47c6334">More...</a><br /></td></tr>
<tr class="separator:ad69eefd0ab8ef5ec77054e20b47c6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bd63694faf3df7596b0254706f92a1"><td class="memItemLeft" align="right" valign="top"><a id="a36bd63694faf3df7596b0254706f92a1"></a>
virtual <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a36bd63694faf3df7596b0254706f92a1">self_fuse</a> ()=0</td></tr>
<tr class="memdesc:a36bd63694faf3df7596b0254706f92a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for operator fusion. Merge this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a> with an identical copy. If no match return NULL. <br /></td></tr>
<tr class="separator:a36bd63694faf3df7596b0254706f92a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The abstract operator for the operation stack <code><a class="el" href="structTMBad_1_1global.html#ac67f7cc38f0893edccbfd5a603536685" title="Operation stack. ">global::opstack</a></code> </p>
<ul>
<li>The methods in this class must be implemented for all operators. However, in practice most members can be autogenerated by the <code><a class="el" href="structTMBad_1_1global_1_1Complete.html" title="Operator auto-completion. ">Complete</a></code> class. <dl class="section note"><dt>Note</dt><dd>Virtual member functions are associated with a significant overhead (vtable lookup). For performance reasons, it is therefore important to squeeze as much work as possible into these virtual methods. </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l00811">811</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ebeb799cadd483b2305b0bec3b7c810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebeb799cadd483b2305b0bec3b7c810">&sect;&nbsp;</a></span>dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1Args.html">Args</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dependencies &amp;&#160;</td>
          <td class="paramname"><em>dep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the indices of variables required by this operator. </p>
<p>Result of this operation (the indices) are <em>appended</em> to the <code>dep</code> argument. Its main purpose is to build the computational graph. Under normal circumstances the information can be autogenerated from the operator inputs. However there is a subtle exception: Operators are allowed to take reference inputs. For instance a matrix multiply only requires addresses of the first element of the two input matrices. Such cases must have special code to provide <b>all</b> input addresses. </p><dl class="section note"><dt>Note</dt><dd>This information is somewhat overlapping with that of <code>reverse(<a class="el" href="structTMBad_1_1ReverseArgs.html" title="Access input/output values and derivatives during a reverse pass. Write access granted for the input ...">ReverseArgs</a>&lt;Replay&gt;&amp; args)</code>. </dd></dl>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a32848b186f77afb69214d202cde051f3">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a32848b186f77afb69214d202cde051f3">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a2d52c4ff3af471f601fc9d82591a3f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d52c4ff3af471f601fc9d82591a3f68">&sect;&nbsp;</a></span>dependencies_updating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::dependencies_updating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1Args.html">Args</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dependencies &amp;&#160;</td>
          <td class="paramname"><em>dep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the indices of variables updated by this operator. </p>
<p>Used only when <code><a class="el" href="structTMBad_1_1global_1_1Operator.html#a543345b436f11969c493a8cf4b034463" title="This operator may update existing variables ? ">Operator::updating</a></code> flag is set. </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a106400a83f6387c1650ccbd35c6b9b5b">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a106400a83f6387c1650ccbd35c6b9b5b">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="aca01e0291993b4c08cc1311bada7ab39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01e0291993b4c08cc1311bada7ab39">&sect;&nbsp;</a></span>forward() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark forward dependencies. </p>
<p>Calculate \(y=Jx\) where \(J\) denotes the Jacobian sparsity pattern of the operator. Operators are by default assumed to be dense. </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a20afcf005885171cbef76538eacc48b1">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a20afcf005885171cbef76538eacc48b1">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a9ad50faaa3b28e37ba37555fac7ac844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad50faaa3b28e37ba37555fac7ac844">&sect;&nbsp;</a></span>forward() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Replay &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replay operation sequence. </p>
<p>Update output values of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>.</p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a2fa5fdf69591bcd4de3680ba07c9acf6">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a2fa5fdf69591bcd4de3680ba07c9acf6">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="abad5f0d6bc1ec1c9e8218c5de2ab4468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad5f0d6bc1ec1c9e8218c5de2ab4468">&sect;&nbsp;</a></span>forward() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Writer &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source code writer. </p>
<p>Update output values of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>.</p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a52d76df106134cba6ecf85b6dbaa0b8a">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a52d76df106134cba6ecf85b6dbaa0b8a">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="aef2c25c615cb04d648a86e1825724891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2c25c615cb04d648a86e1825724891">&sect;&nbsp;</a></span>forward_incr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b" title="Update output values of this OperatorPure. ">forward()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737" title="Increment input/output pointers to prepare for the next OperatorPure in the stack. ">increment()</a></code> </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a00eb4a750401bc342d2790c5ea427e14">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a00eb4a750401bc342d2790c5ea427e14">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a6ac7989da0024e46399c68c1ec0973ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac7989da0024e46399c68c1ec0973ad">&sect;&nbsp;</a></span>forward_incr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Replay &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replay operation sequence. </p>
<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b" title="Update output values of this OperatorPure. ">forward()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737" title="Increment input/output pointers to prepare for the next OperatorPure in the stack. ">increment()</a></code></p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a6ce5c2caef7aca6f47041ff6eee8731b">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a6ce5c2caef7aca6f47041ff6eee8731b">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a4646bc7cfcb7ba3663da1f079c486f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4646bc7cfcb7ba3663da1f079c486f46">&sect;&nbsp;</a></span>forward_incr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::forward_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a>&lt; Writer &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source code writer. </p>
<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#afe5f99dd4f7776763c45ca590719197b" title="Update output values of this OperatorPure. ">forward()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a843683185bebb0e7abfb6fe39d82f737" title="Increment input/output pointers to prepare for the next OperatorPure in the stack. ">increment()</a></code></p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#abaa256928ac37f868ba5c3b566f0915c">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#abaa256928ac37f868ba5c3b566f0915c">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a112474b01b04462a0819883905824932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112474b01b04462a0819883905824932">&sect;&nbsp;</a></span>identifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* TMBad::global::OperatorPure::identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> identifier. </p>
<p>If two operators have equal identifier it can be assumed that they represent equal mappings, i.e. same input implies same output. </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a44f2761667e03f2b50f8f69182e2d6dc">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a44f2761667e03f2b50f8f69182e2d6dc">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#af1eaffa26abd798259f48bd225838090">TMBad::remap_identical_sub_expressions()</a>.</p>

</div>
</div>
<a id="a2e7d39b97134ff35fe310c03634c7189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7d39b97134ff35fe310c03634c7189">&sect;&nbsp;</a></span>incomplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* TMBad::global::OperatorPure::incomplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to operator before it was completed. </p>
<dl class="section warning"><dt>Warning</dt><dd>Avoid unless strictly necessary </dd></dl>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a3a67e61f1e96fd5d62922a7bfb7576d7">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a3a67e61f1e96fd5d62922a7bfb7576d7">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a5ac0148046a58730801cd66afe201fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac0148046a58730801cd66afe201fee">&sect;&nbsp;</a></span>reverse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark reverse dependencies. </p>
<p>Calculate \(x=J^Ty\) where \(J\) denotes the Jacobian sparsity pattern of the operator. Operators are by default assumed to be dense. </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#afcb980f4eaf4f213d9b2b894c5ebd858">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#afcb980f4eaf4f213d9b2b894c5ebd858">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="ab6e47c64e0c1b4097ed2b5d0f2d7388e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e47c64e0c1b4097ed2b5d0f2d7388e">&sect;&nbsp;</a></span>reverse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Replay &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replay operation sequence. </p>
<p>Update input derivs of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>.</p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#ae09a2f0865157cab3865831cf3edf367">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#ae09a2f0865157cab3865831cf3edf367">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="ac8204f094377b82cf5db000b4b2896fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8204f094377b82cf5db000b4b2896fd">&sect;&nbsp;</a></span>reverse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Writer &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source code writer. </p>
<p>Update input derivs of this <a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a>.</p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a7df8b9c65a786d42258286e1f4a9476f">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a7df8b9c65a786d42258286e1f4a9476f">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a9c5486ac653339fb30a3f76a4d150536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5486ac653339fb30a3f76a4d150536">&sect;&nbsp;</a></span>reverse_decr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465" title="Decrement input/output pointers to prepare for the previous OperatorPure in the stack. ">decrement()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658" title="Update input derivs of this OperatorPure. ">reverse()</a></code> </p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a45567cadeb7f72a6ea717759f44b22c2">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a45567cadeb7f72a6ea717759f44b22c2">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="a64aacea34cbf8c56e1d2d1e639b9b3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64aacea34cbf8c56e1d2d1e639b9b3c2">&sect;&nbsp;</a></span>reverse_decr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Replay &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replay operation sequence. </p>
<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465" title="Decrement input/output pointers to prepare for the previous OperatorPure in the stack. ">decrement()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658" title="Update input derivs of this OperatorPure. ">reverse()</a></code></p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#ae28911f572b7371e71c4b77900a222f1">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#ae28911f572b7371e71c4b77900a222f1">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad69eefd0ab8ef5ec77054e20b47c6334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69eefd0ab8ef5ec77054e20b47c6334">&sect;&nbsp;</a></span>reverse_decr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TMBad::global::OperatorPure::reverse_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a>&lt; Writer &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source code writer. </p>
<p>Fast equivalent of combined <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a9dbf920a9ec8270222dbb960c4567465" title="Decrement input/output pointers to prepare for the previous OperatorPure in the stack. ">decrement()</a></code> <em>and</em> <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a121f1f604268a28a3afd664d04bbe658" title="Update input derivs of this OperatorPure. ">reverse()</a></code></p>

<p>Implemented in <a class="el" href="structTMBad_1_1global_1_1Complete.html#a78a32f3385292aa9a3acc3e4ebb654aa">TMBad::global::Complete&lt; OperatorBase &gt;</a>, and <a class="el" href="structTMBad_1_1global_1_1Complete.html#a78a32f3385292aa9a3acc3e4ebb654aa">TMBad::global::Complete&lt; SpAxOp&lt; T &gt; &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="global_8hpp_source.html">global.hpp</a></li>
</ul>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
