<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: TMBad::global Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTMBad.html">TMBad</a></li><li class="navelem"><a class="el" href="structTMBad_1_1global.html">global</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structTMBad_1_1global-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TMBad::global Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Struct defining the main AD context.  
 <a href="structTMBad_1_1global.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="global_8hpp_source.html">global.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augmented AD type.  <a href="structTMBad_1_1global_1_1ad__aug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous set of variables on the <em>current</em> tape.  <a href="structTMBad_1_1global_1_1ad__segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddDependencies.html">AddDependencies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory member: <code>dependencies</code>  <a href="structTMBad_1_1global_1_1AddDependencies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardFromEval.html">AddForwardFromEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory member: <code>forward</code> <b>from</b> optional member <code>eval</code>  <a href="structTMBad_1_1global_1_1AddForwardFromEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardFromEval_3_01OperatorBase_00_011_01_4.html">AddForwardFromEval&lt; OperatorBase, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary case.  <a href="structTMBad_1_1global_1_1AddForwardFromEval_3_01OperatorBase_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardFromEval_3_01OperatorBase_00_012_01_4.html">AddForwardFromEval&lt; OperatorBase, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary case.  <a href="structTMBad_1_1global_1_1AddForwardFromEval_3_01OperatorBase_00_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardIncrReverseDecr.html">AddForwardIncrReverseDecr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory members: <code>forward_incr</code> and <code>reverse_decr</code> <b>from</b> <code>forward</code> and <code>reverse</code>  <a href="structTMBad_1_1global_1_1AddForwardIncrReverseDecr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardMarkReverseMark.html">AddForwardMarkReverseMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory members: <code>forward_mark</code> and <code>reverse_mark</code>  <a href="structTMBad_1_1global_1_1AddForwardMarkReverseMark.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddForwardReverse.html">AddForwardReverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory members: <code>forward</code> and <code>reverse</code> <b>from</b> <code>forward_incr</code> and <code>reverse_decr</code>  <a href="structTMBad_1_1global_1_1AddForwardReverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddIncrementDecrement.html">AddIncrementDecrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory members: <code>increment</code> and <code>decrement</code>  <a href="structTMBad_1_1global_1_1AddIncrementDecrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1AddInputSizeOutputSize.html">AddInputSizeOutputSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add default implementation of mandatory members: <code>input_size</code> ans <code>output_size</code>  <a href="structTMBad_1_1global_1_1AddInputSizeOutputSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1Complete.html">Complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> auto-completion.  <a href="structTMBad_1_1global_1_1Complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1CPL.html">CPL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all mandatory members.  <a href="structTMBad_1_1global_1_1CPL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1DynamicOperator.html">DynamicOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> that requires dynamic allocation. Compile time known input/output size.  <a href="structTMBad_1_1global_1_1DynamicOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1DynamicOutputOperator.html">DynamicOutputOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> that requires dynamic allocation. Compile time known input size.  <a href="structTMBad_1_1global_1_1DynamicOutputOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1Fused.html">Fused</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two operators.  <a href="structTMBad_1_1global_1_1Fused.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1hash__config.html">hash_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of hash_sweep.  <a href="structTMBad_1_1global_1_1hash__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1if__else.html">if_else</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for member completion.  <a href="structTMBad_1_1global_1_1if__else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1no__filter.html">no_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute of std::vector&lt;bool&gt; with all elements <code>true</code>  <a href="structTMBad_1_1global_1_1no__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1NullOp.html">NullOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty operator <b>without</b> inputs or outputs.  <a href="structTMBad_1_1global_1_1NullOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1NullOp2.html">NullOp2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty operator <b>with</b> inputs and outputs.  <a href="structTMBad_1_1global_1_1NullOp2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1operation__stack.html">operation_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation stack.  <a href="structTMBad_1_1global_1_1operation__stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTMBad_1_1global_1_1Operator.html" title="Operator with input/output dimension known at compile time. ">Operator</a> with input/output dimension known at compile time.  <a href="structTMBad_1_1global_1_1Operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract operator for the operation stack <code><a class="el" href="structTMBad_1_1global.html#ac67f7cc38f0893edccbfd5a603536685" title="Operation stack. ">global::opstack</a></code>  <a href="structTMBad_1_1global_1_1OperatorPure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1print__config.html">print_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of print method.  <a href="structTMBad_1_1global_1_1print__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting.  <a href="structTMBad_1_1global_1_1ReferenceCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1RefOp.html">RefOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference a variable on another tape.  <a href="structTMBad_1_1global_1_1RefOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1Rep.html">Rep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate an operator.  <a href="structTMBad_1_1global_1_1Rep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1RepCompress.html">RepCompress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate an operator and apply input compression.  <a href="structTMBad_1_1global_1_1RepCompress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global_1_1ZeroOp.html">ZeroOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add zero allocated workspace to the tape.  <a href="structTMBad_1_1global_1_1ZeroOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a2d146e97f051dc2a4ae2de004d64e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a4a2d146e97f051dc2a4ae2de004d64e7">ad_start</a> ()</td></tr>
<tr class="memdesc:a4a2d146e97f051dc2a4ae2de004d64e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ad calulations to be piped to this glob.  <a href="#a4a2d146e97f051dc2a4ae2de004d64e7">More...</a><br /></td></tr>
<tr class="separator:a4a2d146e97f051dc2a4ae2de004d64e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ac1ed235900325b0b6d216973397b"><td class="memItemLeft" align="right" valign="top"><a id="a576ac1ed235900325b0b6d216973397b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a576ac1ed235900325b0b6d216973397b">ad_stop</a> ()</td></tr>
<tr class="memdesc:a576ac1ed235900325b0b6d216973397b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop ad calculations from being piped to this glob. <br /></td></tr>
<tr class="separator:a576ac1ed235900325b0b6d216973397b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa76602a5953edfe5ec8393b786970"><td class="memItemLeft" align="right" valign="top"><a id="ae0aa76602a5953edfe5ec8393b786970"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ae0aa76602a5953edfe5ec8393b786970">add_to_opstack</a> (<a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *pOp)</td></tr>
<tr class="memdesc:ae0aa76602a5953edfe5ec8393b786970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html" title="The abstract operator for the operation stack global::opstack ">OperatorPure</a></code> to stack and trigger operator fusion if enabled. <br /></td></tr>
<tr class="separator:ae0aa76602a5953edfe5ec8393b786970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5185a4a7bdcebc6a5610493a07e751f"><td class="memTemplParams" colspan="2"><a id="ac5185a4a7bdcebc6a5610493a07e751f"></a>
template&lt;class OperatorBase &gt; </td></tr>
<tr class="memitem:ac5185a4a7bdcebc6a5610493a07e751f"><td class="memTemplItemLeft" align="right" valign="top">ad_plain&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ac5185a4a7bdcebc6a5610493a07e751f">add_to_stack</a> (Scalar result=0)</td></tr>
<tr class="memdesc:ac5185a4a7bdcebc6a5610493a07e751f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add nullary operator to the stack based on its <b>result</b> <br /></td></tr>
<tr class="separator:ac5185a4a7bdcebc6a5610493a07e751f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0338dab4425fae61859215d21d47b8"><td class="memTemplParams" colspan="2"><a id="aab0338dab4425fae61859215d21d47b8"></a>
template&lt;class OperatorBase &gt; </td></tr>
<tr class="memitem:aab0338dab4425fae61859215d21d47b8"><td class="memTemplItemLeft" align="right" valign="top">ad_plain&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aab0338dab4425fae61859215d21d47b8">add_to_stack</a> (const ad_plain &amp;x)</td></tr>
<tr class="memdesc:aab0338dab4425fae61859215d21d47b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add unary operator to the stack based on its <b>argument</b> <br /></td></tr>
<tr class="separator:aab0338dab4425fae61859215d21d47b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f22e479ca8c0f2d155c0188abad28a2"><td class="memTemplParams" colspan="2"><a id="a9f22e479ca8c0f2d155c0188abad28a2"></a>
template&lt;class OperatorBase &gt; </td></tr>
<tr class="memitem:a9f22e479ca8c0f2d155c0188abad28a2"><td class="memTemplItemLeft" align="right" valign="top">ad_plain&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a9f22e479ca8c0f2d155c0188abad28a2">add_to_stack</a> (const ad_plain &amp;x, const ad_plain &amp;y)</td></tr>
<tr class="memdesc:a9f22e479ca8c0f2d155c0188abad28a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add binary operator to the stack based on its two <b>arguments</b> <br /></td></tr>
<tr class="separator:a9f22e479ca8c0f2d155c0188abad28a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7a671bde2d50af51c70d3b744fac21"><td class="memTemplParams" colspan="2"><a id="a9e7a671bde2d50af51c70d3b744fac21"></a>
template&lt;class OperatorBase &gt; </td></tr>
<tr class="memitem:a9e7a671bde2d50af51c70d3b744fac21"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ad_plain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a9e7a671bde2d50af51c70d3b744fac21">add_to_stack</a> (<a class="el" href="structTMBad_1_1global_1_1OperatorPure.html">OperatorPure</a> *pOp, const std::vector&lt; ad_plain &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e7a671bde2d50af51c70d3b744fac21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add vector operator to the stack based on its <b>vector argument</b> <br /></td></tr>
<tr class="separator:a9e7a671bde2d50af51c70d3b744fac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36585b11441e3df8b4b12c58cb9759fe"><td class="memItemLeft" align="right" valign="top"><a id="a36585b11441e3df8b4b12c58cb9759fe"></a>
Position&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a36585b11441e3df8b4b12c58cb9759fe">begin</a> ()</td></tr>
<tr class="memdesc:a36585b11441e3df8b4b12c58cb9759fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three pointers defining the begining of the tape. <br /></td></tr>
<tr class="separator:a36585b11441e3df8b4b12c58cb9759fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e8e93a598108e047a1fa68bb9a0cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1graph.html">graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a23e8e93a598108e047a1fa68bb9a0cf6">build_graph</a> (bool transpose, const std::vector&lt; bool &gt; &amp;keep_var)</td></tr>
<tr class="memdesc:a23e8e93a598108e047a1fa68bb9a0cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a graph-representation of the operation stack.  <a href="#a23e8e93a598108e047a1fa68bb9a0cf6">More...</a><br /></td></tr>
<tr class="separator:a23e8e93a598108e047a1fa68bb9a0cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29518fc35dd8f9c733a51739aac7786c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a29518fc35dd8f9c733a51739aac7786c">clear</a> ()</td></tr>
<tr class="memdesc:a29518fc35dd8f9c733a51739aac7786c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all workspace without actually freeing the workspace.  <a href="#a29518fc35dd8f9c733a51739aac7786c">More...</a><br /></td></tr>
<tr class="separator:a29518fc35dd8f9c733a51739aac7786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d7d23b96392bb9f92a0799a26a874f"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ad0d7d23b96392bb9f92a0799a26a874f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ad0d7d23b96392bb9f92a0799a26a874f">clear_array_subgraph</a> (Vector &amp;<a class="el" href="structarray.html">array</a>, typename Vector::value_type <a class="el" href="namespaceTMBad.html#ae0f11020200051df812c0540a9cf7d02">value</a>=typename Vector::value_type(0)) const</td></tr>
<tr class="memdesc:ad0d7d23b96392bb9f92a0799a26a874f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic clear array along global::subgraph.  <a href="#ad0d7d23b96392bb9f92a0799a26a874f">More...</a><br /></td></tr>
<tr class="separator:ad0d7d23b96392bb9f92a0799a26a874f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fbfe5560ea16ec5102823153517a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a90fbfe5560ea16ec5102823153517a50">clear_deriv</a> (Position start=Position(0, 0, 0))</td></tr>
<tr class="memdesc:a90fbfe5560ea16ec5102823153517a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set derivatives to zero.  <a href="#a90fbfe5560ea16ec5102823153517a50">More...</a><br /></td></tr>
<tr class="separator:a90fbfe5560ea16ec5102823153517a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75e4a0c3c3b2cfab165b03881ef5d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a9c75e4a0c3c3b2cfab165b03881ef5d7">clear_deriv_sub</a> ()</td></tr>
<tr class="memdesc:a9c75e4a0c3c3b2cfab165b03881ef5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear derivative array along a subgraph.  <a href="#a9c75e4a0c3c3b2cfab165b03881ef5d7">More...</a><br /></td></tr>
<tr class="separator:a9c75e4a0c3c3b2cfab165b03881ef5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7dda29750d7341e4fb39c03399fa3"><td class="memItemLeft" align="right" valign="top"><a id="a59e7dda29750d7341e4fb39c03399fa3"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a59e7dda29750d7341e4fb39c03399fa3">dep_marks</a> ()</td></tr>
<tr class="memdesc:a59e7dda29750d7341e4fb39c03399fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean representation of dependent variable positions. <br /></td></tr>
<tr class="separator:a59e7dda29750d7341e4fb39c03399fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2340f4e3f81e1e877345fa197b4ae2ba"><td class="memItemLeft" align="right" valign="top"><a id="a2340f4e3f81e1e877345fa197b4ae2ba"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a2340f4e3f81e1e877345fa197b4ae2ba">deriv_dep</a> (Index i)</td></tr>
<tr class="memdesc:a2340f4e3f81e1e877345fa197b4ae2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to i'th 'range direction' used to seed the derivative. <br /></td></tr>
<tr class="separator:a2340f4e3f81e1e877345fa197b4ae2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf040624d5f8cf65cd99a8a8fbe41fd"><td class="memItemLeft" align="right" valign="top"><a id="a1cf040624d5f8cf65cd99a8a8fbe41fd"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a1cf040624d5f8cf65cd99a8a8fbe41fd">deriv_inv</a> (Index i)</td></tr>
<tr class="memdesc:a1cf040624d5f8cf65cd99a8a8fbe41fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to i'th component of the gradient. <br /></td></tr>
<tr class="separator:a1cf040624d5f8cf65cd99a8a8fbe41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6a949ba45e07c3011c0452693fc054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aec6a949ba45e07c3011c0452693fc054">eliminate</a> ()</td></tr>
<tr class="memdesc:aec6a949ba45e07c3011c0452693fc054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple tape optimizer.  <a href="#aec6a949ba45e07c3011c0452693fc054">More...</a><br /></td></tr>
<tr class="separator:aec6a949ba45e07c3011c0452693fc054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69025186f8340ae2047612fb72ebc062"><td class="memItemLeft" align="right" valign="top"><a id="a69025186f8340ae2047612fb72ebc062"></a>
Position&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a69025186f8340ae2047612fb72ebc062">end</a> ()</td></tr>
<tr class="memdesc:a69025186f8340ae2047612fb72ebc062"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three pointers defining the end of the tape. <br /></td></tr>
<tr class="separator:a69025186f8340ae2047612fb72ebc062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96198fbf4f41e224f9ac150a6e99344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global.html">global</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#af96198fbf4f41e224f9ac150a6e99344">extract_sub</a> (std::vector&lt; Index &gt; &amp;var_remap, <a class="el" href="structTMBad_1_1global.html">global</a> new_glob=<a class="el" href="structTMBad_1_1global.html">global</a>())</td></tr>
<tr class="memdesc:af96198fbf4f41e224f9ac150a6e99344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subgraph as a new global object. Fast when called many times.  <a href="#af96198fbf4f41e224f9ac150a6e99344">More...</a><br /></td></tr>
<tr class="separator:af96198fbf4f41e224f9ac150a6e99344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6b8b5744ae25b8c0a1e47a3b6c2e08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global.html">global</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aaa6b8b5744ae25b8c0a1e47a3b6c2e08">extract_sub</a> ()</td></tr>
<tr class="memdesc:aaa6b8b5744ae25b8c0a1e47a3b6c2e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subgraph as a new global object. Slow when called many times.  <a href="#aaa6b8b5744ae25b8c0a1e47a3b6c2e08">More...</a><br /></td></tr>
<tr class="separator:aaa6b8b5744ae25b8c0a1e47a3b6c2e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0be543105b173bdab6874ab3479190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a6e0be543105b173bdab6874ab3479190">extract_sub_inplace</a> (std::vector&lt; bool &gt; marks)</td></tr>
<tr class="memdesc:a6e0be543105b173bdab6874ab3479190"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subgraph extractor.  <a href="#a6e0be543105b173bdab6874ab3479190">More...</a><br /></td></tr>
<tr class="separator:a6e0be543105b173bdab6874ab3479190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2700550d94c96c7a2b437354fac8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aef2700550d94c96c7a2b437354fac8d7">forward</a> (Position start=Position(0, 0, 0))</td></tr>
<tr class="memdesc:aef2700550d94c96c7a2b437354fac8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full or partial forward sweep through the operation stack. Updates <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code>.  <a href="#aef2700550d94c96c7a2b437354fac8d7">More...</a><br /></td></tr>
<tr class="separator:aef2700550d94c96c7a2b437354fac8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57980bf0942d3bb518ca8386c00f0ca7"><td class="memItemLeft" align="right" valign="top"><a id="a57980bf0942d3bb518ca8386c00f0ca7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a57980bf0942d3bb518ca8386c00f0ca7">forward</a> (std::vector&lt; bool &gt; &amp;marks)</td></tr>
<tr class="memdesc:a57980bf0942d3bb518ca8386c00f0ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full forward dependency sweep through the operation stack. <br /></td></tr>
<tr class="separator:a57980bf0942d3bb518ca8386c00f0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455b14752a03b03770a543af16daaf38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a455b14752a03b03770a543af16daaf38">forward_dense</a> (std::vector&lt; bool &gt; &amp;marks)</td></tr>
<tr class="memdesc:a455b14752a03b03770a543af16daaf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full forward dependency sweep through the operation stack.  <a href="#a455b14752a03b03770a543af16daaf38">More...</a><br /></td></tr>
<tr class="separator:a455b14752a03b03770a543af16daaf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1e113f676e1f266a1e86c32af6ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1graph.html">graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a7dc1e113f676e1f266a1e86c32af6ef8">forward_graph</a> (std::vector&lt; bool &gt; keep_var=std::vector&lt; bool &gt;(0))</td></tr>
<tr class="memdesc:a7dc1e113f676e1f266a1e86c32af6ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct operator graph with forward connections.  <a href="#a7dc1e113f676e1f266a1e86c32af6ef8">More...</a><br /></td></tr>
<tr class="separator:a7dc1e113f676e1f266a1e86c32af6ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b377010b34268039733176938d51c0"><td class="memTemplParams" colspan="2">template&lt;class ForwardArgs , class NodeFilter &gt; </td></tr>
<tr class="memitem:a97b377010b34268039733176938d51c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a97b377010b34268039733176938d51c0">forward_loop</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a> &amp;args, size_t <a class="el" href="structTMBad_1_1global.html#a36585b11441e3df8b4b12c58cb9759fe">begin</a>, const NodeFilter &amp;node_filter) const</td></tr>
<tr class="memdesc:a97b377010b34268039733176938d51c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic forward sweep.  <a href="#a97b377010b34268039733176938d51c0">More...</a><br /></td></tr>
<tr class="separator:a97b377010b34268039733176938d51c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68a680c2059a12235247e82eab79d4"><td class="memTemplParams" colspan="2">template&lt;class ForwardArgs &gt; </td></tr>
<tr class="memitem:a1e68a680c2059a12235247e82eab79d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a1e68a680c2059a12235247e82eab79d4">forward_loop</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a> &amp;args, size_t <a class="el" href="structTMBad_1_1global.html#a36585b11441e3df8b4b12c58cb9759fe">begin</a>=0) const</td></tr>
<tr class="memdesc:a1e68a680c2059a12235247e82eab79d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic forward sweep.  <a href="#a1e68a680c2059a12235247e82eab79d4">More...</a><br /></td></tr>
<tr class="separator:a1e68a680c2059a12235247e82eab79d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac217c1fc6e6773ea41c0e413a3944f"><td class="memTemplParams" colspan="2"><a id="a6ac217c1fc6e6773ea41c0e413a3944f"></a>
template&lt;class ForwardArgs &gt; </td></tr>
<tr class="memitem:a6ac217c1fc6e6773ea41c0e413a3944f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a6ac217c1fc6e6773ea41c0e413a3944f">forward_loop_subgraph</a> (<a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a> &amp;args) const</td></tr>
<tr class="memdesc:a6ac217c1fc6e6773ea41c0e413a3944f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic forward sweep along global::subgraph_seq. <br /></td></tr>
<tr class="separator:a6ac217c1fc6e6773ea41c0e413a3944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3a5ad844e2088bb90c4aef16f631fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a8b3a5ad844e2088bb90c4aef16f631fd">forward_replay</a> (bool inv_tags=true, bool dep_tags=true)</td></tr>
<tr class="memdesc:a8b3a5ad844e2088bb90c4aef16f631fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay this operation sequence to itself.  <a href="#a8b3a5ad844e2088bb90c4aef16f631fd">More...</a><br /></td></tr>
<tr class="separator:a8b3a5ad844e2088bb90c4aef16f631fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948fb62a7ca3a87b9e312c709c1a6c1e"><td class="memItemLeft" align="right" valign="top"><a id="a948fb62a7ca3a87b9e312c709c1a6c1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a948fb62a7ca3a87b9e312c709c1a6c1e">forward_sub</a> ()</td></tr>
<tr class="memdesc:a948fb62a7ca3a87b9e312c709c1a6c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward sweep along a subgraph. <br /></td></tr>
<tr class="separator:a948fb62a7ca3a87b9e312c709c1a6c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539d2980fad2c33ff46606194ce30d56"><td class="memItemLeft" align="right" valign="top"><a id="a539d2980fad2c33ff46606194ce30d56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a539d2980fad2c33ff46606194ce30d56">forward_sub</a> (std::vector&lt; bool &gt; &amp;marks, const std::vector&lt; bool &gt; &amp;node_filter=std::vector&lt; bool &gt;())</td></tr>
<tr class="memdesc:a539d2980fad2c33ff46606194ce30d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward sweep along a subgraph. Subgraph can be specified through a sequence <code>subgraph_seq</code> (default) or through a boolean <code>node_filter</code>. <br /></td></tr>
<tr class="separator:a539d2980fad2c33ff46606194ce30d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d1cc668ce7dbae6be0df8305eff8b9"><td class="memTemplParams" colspan="2"><a id="ac4d1cc668ce7dbae6be0df8305eff8b9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac4d1cc668ce7dbae6be0df8305eff8b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ac4d1cc668ce7dbae6be0df8305eff8b9">hash</a> (hash_t &amp;h, T x) const</td></tr>
<tr class="memdesc:ac4d1cc668ce7dbae6be0df8305eff8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple hash code of scalar. <br /></td></tr>
<tr class="separator:ac4d1cc668ce7dbae6be0df8305eff8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde93efaa23b72a4c006d8f2ffa2b81a"><td class="memItemLeft" align="right" valign="top">hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#afde93efaa23b72a4c006d8f2ffa2b81a">hash</a> () const</td></tr>
<tr class="memdesc:afde93efaa23b72a4c006d8f2ffa2b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple hash code of tape.  <a href="#afde93efaa23b72a4c006d8f2ffa2b81a">More...</a><br /></td></tr>
<tr class="separator:afde93efaa23b72a4c006d8f2ffa2b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c705966ba5c49c15bc2613ced3768aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hash_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a8c705966ba5c49c15bc2613ced3768aa">hash_sweep</a> (<a class="el" href="structTMBad_1_1global_1_1hash__config.html">hash_config</a> cfg) const</td></tr>
<tr class="memdesc:a8c705966ba5c49c15bc2613ced3768aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate hash codes of each dependent variable using a single forward sweep.  <a href="#a8c705966ba5c49c15bc2613ced3768aa">More...</a><br /></td></tr>
<tr class="separator:a8c705966ba5c49c15bc2613ced3768aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5058e263dc15bd27b1e87277aa7670"><td class="memItemLeft" align="right" valign="top"><a id="acd5058e263dc15bd27b1e87277aa7670"></a>
std::vector&lt; hash_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#acd5058e263dc15bd27b1e87277aa7670">hash_sweep</a> (bool weak=true) const</td></tr>
<tr class="memdesc:acd5058e263dc15bd27b1e87277aa7670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle two common cases. <br /></td></tr>
<tr class="separator:acd5058e263dc15bd27b1e87277aa7670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7257275d5fbfbc0f6a8ef8bc1227cbb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a7257275d5fbfbc0f6a8ef8bc1227cbb9">identical</a> (const <a class="el" href="structTMBad_1_1global.html">global</a> &amp;other) const</td></tr>
<tr class="memdesc:a7257275d5fbfbc0f6a8ef8bc1227cbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two tapes are identical.  <a href="#a7257275d5fbfbc0f6a8ef8bc1227cbb9">More...</a><br /></td></tr>
<tr class="separator:a7257275d5fbfbc0f6a8ef8bc1227cbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874d26ba228701e0b724664d7cf302c"><td class="memItemLeft" align="right" valign="top"><a id="a4874d26ba228701e0b724664d7cf302c"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a4874d26ba228701e0b724664d7cf302c">inv_marks</a> ()</td></tr>
<tr class="memdesc:a4874d26ba228701e0b724664d7cf302c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean representation of independent variable positions. <br /></td></tr>
<tr class="separator:a4874d26ba228701e0b724664d7cf302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b0a15a25ce60054e0fe3206c2abaa3"><td class="memItemLeft" align="right" valign="top"><a id="ab0b0a15a25ce60054e0fe3206c2abaa3"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ab0b0a15a25ce60054e0fe3206c2abaa3">mark_space</a> (size_t n, const std::vector&lt; Index &gt; ind)</td></tr>
<tr class="memdesc:ab0b0a15a25ce60054e0fe3206c2abaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">General boolean table generator. <br /></td></tr>
<tr class="separator:ab0b0a15a25ce60054e0fe3206c2abaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173ce2afde74ac1280802a5ba644266"><td class="memItemLeft" align="right" valign="top"><a id="a6173ce2afde74ac1280802a5ba644266"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a6173ce2afde74ac1280802a5ba644266">mark_subgraph</a> (std::vector&lt; bool &gt; &amp;marks)</td></tr>
<tr class="memdesc:a6173ce2afde74ac1280802a5ba644266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all outputs of a subgraph. <br /></td></tr>
<tr class="separator:a6173ce2afde74ac1280802a5ba644266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463cc358b18ec2160cab32a0dcfab95c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a463cc358b18ec2160cab32a0dcfab95c">op2idx</a> (const std::vector&lt; Index &gt; &amp;var_subset, Index NA=(Index) -1)</td></tr>
<tr class="memdesc:a463cc358b18ec2160cab32a0dcfab95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General operator -&gt; variable table generator.  <a href="#a463cc358b18ec2160cab32a0dcfab95c">More...</a><br /></td></tr>
<tr class="separator:a463cc358b18ec2160cab32a0dcfab95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef36053bc61dce1beb5e02ef0a41538"><td class="memItemLeft" align="right" valign="top"><a id="a6ef36053bc61dce1beb5e02ef0a41538"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a6ef36053bc61dce1beb5e02ef0a41538">op2var</a> (const std::vector&lt; Index &gt; &amp;seq)</td></tr>
<tr class="memdesc:a6ef36053bc61dce1beb5e02ef0a41538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get variables produces by a node seqence. <br /></td></tr>
<tr class="separator:a6ef36053bc61dce1beb5e02ef0a41538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a069954deba4d4e7d027ff5b9d3b0"><td class="memItemLeft" align="right" valign="top"><a id="abf5a069954deba4d4e7d027ff5b9d3b0"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#abf5a069954deba4d4e7d027ff5b9d3b0">op2var</a> (const std::vector&lt; bool &gt; &amp;seq_mark)</td></tr>
<tr class="memdesc:abf5a069954deba4d4e7d027ff5b9d3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get variables produced by a node seqence. <br /></td></tr>
<tr class="separator:abf5a069954deba4d4e7d027ff5b9d3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fcf1d965e321077c54e0dafc066746"><td class="memItemLeft" align="right" valign="top"><a id="a18fcf1d965e321077c54e0dafc066746"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a18fcf1d965e321077c54e0dafc066746">print</a> (<a class="el" href="structTMBad_1_1global_1_1print__config.html">print_config</a> cfg)</td></tr>
<tr class="memdesc:a18fcf1d965e321077c54e0dafc066746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print workspace. <br /></td></tr>
<tr class="separator:a18fcf1d965e321077c54e0dafc066746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6f66b7b08ec0bb5da1ed01d327dd02"><td class="memItemLeft" align="right" valign="top"><a id="aef6f66b7b08ec0bb5da1ed01d327dd02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aef6f66b7b08ec0bb5da1ed01d327dd02">print</a> ()</td></tr>
<tr class="memdesc:aef6f66b7b08ec0bb5da1ed01d327dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print workspace with default configuration (works from debugger) <br /></td></tr>
<tr class="separator:aef6f66b7b08ec0bb5da1ed01d327dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e6551f3ec84d73282701db0d6c6df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ae1e6551f3ec84d73282701db0d6c6df9">reverse</a> (Position start=Position(0, 0, 0))</td></tr>
<tr class="memdesc:ae1e6551f3ec84d73282701db0d6c6df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full or partial reverse sweep through the operation stack. Updates <code><a class="el" href="structTMBad_1_1global.html#ad18a96dd9424824d1469a1f2df118a39" title="Contiguous workspace for derivatives (same length as global::values) ">global::derivs</a></code>.  <a href="#ae1e6551f3ec84d73282701db0d6c6df9">More...</a><br /></td></tr>
<tr class="separator:ae1e6551f3ec84d73282701db0d6c6df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8817a88c90844c0b019a9272851506a6"><td class="memItemLeft" align="right" valign="top"><a id="a8817a88c90844c0b019a9272851506a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a8817a88c90844c0b019a9272851506a6">reverse</a> (std::vector&lt; bool &gt; &amp;marks)</td></tr>
<tr class="memdesc:a8817a88c90844c0b019a9272851506a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full reverse dependency sweep through the operation stack. <br /></td></tr>
<tr class="separator:a8817a88c90844c0b019a9272851506a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88d0db54d389ed8a6950df570749258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1graph.html">graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ac88d0db54d389ed8a6950df570749258">reverse_graph</a> (std::vector&lt; bool &gt; keep_var=std::vector&lt; bool &gt;(0))</td></tr>
<tr class="memdesc:ac88d0db54d389ed8a6950df570749258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct operator graph with reverse connections.  <a href="#ac88d0db54d389ed8a6950df570749258">More...</a><br /></td></tr>
<tr class="separator:ac88d0db54d389ed8a6950df570749258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5773910a9aa186762830a4d8a63a827f"><td class="memTemplParams" colspan="2">template&lt;class ReverseArgs , class NodeFilter &gt; </td></tr>
<tr class="memitem:a5773910a9aa186762830a4d8a63a827f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a5773910a9aa186762830a4d8a63a827f">reverse_loop</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a> &amp;args, size_t <a class="el" href="structTMBad_1_1global.html#a36585b11441e3df8b4b12c58cb9759fe">begin</a>, const NodeFilter &amp;node_filter) const</td></tr>
<tr class="memdesc:a5773910a9aa186762830a4d8a63a827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic reverse sweep.  <a href="#a5773910a9aa186762830a4d8a63a827f">More...</a><br /></td></tr>
<tr class="separator:a5773910a9aa186762830a4d8a63a827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe279cafb56f4e47cd1ebc26e602198"><td class="memTemplParams" colspan="2">template&lt;class ReverseArgs &gt; </td></tr>
<tr class="memitem:acfe279cafb56f4e47cd1ebc26e602198"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#acfe279cafb56f4e47cd1ebc26e602198">reverse_loop</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a> &amp;args, size_t <a class="el" href="structTMBad_1_1global.html#a36585b11441e3df8b4b12c58cb9759fe">begin</a>=0) const</td></tr>
<tr class="memdesc:acfe279cafb56f4e47cd1ebc26e602198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic reverse sweep.  <a href="#acfe279cafb56f4e47cd1ebc26e602198">More...</a><br /></td></tr>
<tr class="separator:acfe279cafb56f4e47cd1ebc26e602198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf470755a22832f49cf7ce071392962"><td class="memTemplParams" colspan="2"><a id="a9bf470755a22832f49cf7ce071392962"></a>
template&lt;class ReverseArgs &gt; </td></tr>
<tr class="memitem:a9bf470755a22832f49cf7ce071392962"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a9bf470755a22832f49cf7ce071392962">reverse_loop_subgraph</a> (<a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a> &amp;args) const</td></tr>
<tr class="memdesc:a9bf470755a22832f49cf7ce071392962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic reverse sweep along global::subgraph_seq. <br /></td></tr>
<tr class="separator:a9bf470755a22832f49cf7ce071392962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66898ae105ed1f54858482d504418b2"><td class="memItemLeft" align="right" valign="top"><a id="aa66898ae105ed1f54858482d504418b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aa66898ae105ed1f54858482d504418b2">reverse_sub</a> ()</td></tr>
<tr class="memdesc:aa66898ae105ed1f54858482d504418b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse sweep along a subgraph. <br /></td></tr>
<tr class="separator:aa66898ae105ed1f54858482d504418b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47911998a43d198da1097a988a4cf7d3"><td class="memItemLeft" align="right" valign="top"><a id="a47911998a43d198da1097a988a4cf7d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a47911998a43d198da1097a988a4cf7d3">reverse_sub</a> (std::vector&lt; bool &gt; &amp;marks, const std::vector&lt; bool &gt; &amp;node_filter=std::vector&lt; bool &gt;())</td></tr>
<tr class="memdesc:a47911998a43d198da1097a988a4cf7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse sweep along a subgraph. Subgraph can be specified through a sequence <code>subgraph_seq</code> (default) or through a boolean <code>node_filter</code>. <br /></td></tr>
<tr class="separator:a47911998a43d198da1097a988a4cf7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd2add8d83e70d9aa5fd2853afde922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#acfd2add8d83e70d9aa5fd2853afde922">set_fuse</a> (bool flag)</td></tr>
<tr class="memdesc:acfd2add8d83e70d9aa5fd2853afde922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable operator fusion.  <a href="#acfd2add8d83e70d9aa5fd2853afde922">More...</a><br /></td></tr>
<tr class="separator:acfd2add8d83e70d9aa5fd2853afde922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63eb6061e7c2a714cb2975f361793ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aa63eb6061e7c2a714cb2975f361793ab">set_subgraph</a> (const std::vector&lt; bool &gt; &amp;marks, bool append=false)</td></tr>
<tr class="memdesc:aa63eb6061e7c2a714cb2975f361793ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert selected variables to a subgraph sequence.  <a href="#aa63eb6061e7c2a714cb2975f361793ab">More...</a><br /></td></tr>
<tr class="separator:aa63eb6061e7c2a714cb2975f361793ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef0eb94e36d9b140bf271d7a94e00c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a0ef0eb94e36d9b140bf271d7a94e00c4">shrink_to_fit</a> (double tol=.9)</td></tr>
<tr class="memdesc:a0ef0eb94e36d9b140bf271d7a94e00c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release unnecessary workspace to the system.  <a href="#a0ef0eb94e36d9b140bf271d7a94e00c4">More...</a><br /></td></tr>
<tr class="separator:a0ef0eb94e36d9b140bf271d7a94e00c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af792c941af51a329f7c855c5a491909b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#af792c941af51a329f7c855c5a491909b">subgraph_cache_ptr</a> () const</td></tr>
<tr class="memdesc:af792c941af51a329f7c855c5a491909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache array pointers required by all subgraph routines.  <a href="#af792c941af51a329f7c855c5a491909b">More...</a><br /></td></tr>
<tr class="separator:af792c941af51a329f7c855c5a491909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deb3ad65a7d74a1095863b190676f34"><td class="memItemLeft" align="right" valign="top"><a id="a3deb3ad65a7d74a1095863b190676f34"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a3deb3ad65a7d74a1095863b190676f34">subgraph_marks</a> ()</td></tr>
<tr class="memdesc:a3deb3ad65a7d74a1095863b190676f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean representation of sub graph positions. <br /></td></tr>
<tr class="separator:a3deb3ad65a7d74a1095863b190676f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ea566391a8623d19d02ed3da4ec630"><td class="memItemLeft" align="right" valign="top"><a id="a18ea566391a8623d19d02ed3da4ec630"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a18ea566391a8623d19d02ed3da4ec630">subgraph_trivial</a> ()</td></tr>
<tr class="memdesc:a18ea566391a8623d19d02ed3da4ec630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a full subgraph (for testing only) <br /></td></tr>
<tr class="separator:a18ea566391a8623d19d02ed3da4ec630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66611b36d19f369d6d5727f3c3e4997f"><td class="memItemLeft" align="right" valign="top"><a id="a66611b36d19f369d6d5727f3c3e4997f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a66611b36d19f369d6d5727f3c3e4997f">unmark_subgraph</a> (std::vector&lt; bool &gt; &amp;marks)</td></tr>
<tr class="memdesc:a66611b36d19f369d6d5727f3c3e4997f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmark all outputs of a subgraph. <br /></td></tr>
<tr class="separator:a66611b36d19f369d6d5727f3c3e4997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c249d19df5ecb4a1179f60a11ed70e"><td class="memItemLeft" align="right" valign="top"><a id="ad7c249d19df5ecb4a1179f60a11ed70e"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ad7c249d19df5ecb4a1179f60a11ed70e">value_dep</a> (Index i)</td></tr>
<tr class="memdesc:ad7c249d19df5ecb4a1179f60a11ed70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to i'th component of the function value. <br /></td></tr>
<tr class="separator:ad7c249d19df5ecb4a1179f60a11ed70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b568ec1e426ff33049f9f4eee68009"><td class="memItemLeft" align="right" valign="top"><a id="a28b568ec1e426ff33049f9f4eee68009"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a28b568ec1e426ff33049f9f4eee68009">value_inv</a> (Index i)</td></tr>
<tr class="memdesc:a28b568ec1e426ff33049f9f4eee68009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to i'th input value (parameter) <br /></td></tr>
<tr class="separator:a28b568ec1e426ff33049f9f4eee68009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6e54800e85e7f29d5e82dd130fb89c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a5a6e54800e85e7f29d5e82dd130fb89c">var2op</a> ()</td></tr>
<tr class="memdesc:a5a6e54800e85e7f29d5e82dd130fb89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build variable -&gt; operator node lookup table using a single forward pass. The resulting sequence is monotonically increasing.  <a href="#a5a6e54800e85e7f29d5e82dd130fb89c">More...</a><br /></td></tr>
<tr class="separator:a5a6e54800e85e7f29d5e82dd130fb89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfbe9e7b9f8442b699fd1a6045eab7b"><td class="memItemLeft" align="right" valign="top"><a id="aadfbe9e7b9f8442b699fd1a6045eab7b"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aadfbe9e7b9f8442b699fd1a6045eab7b">var2op</a> (const std::vector&lt; bool &gt; &amp;<a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1">values</a>)</td></tr>
<tr class="memdesc:aadfbe9e7b9f8442b699fd1a6045eab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select operators from a subset of variables An operator is selected if it generates any of the selected variables. This is the fast equivalent of <code>ans[ <a class="el" href="structTMBad_1_1global.html#a5a6e54800e85e7f29d5e82dd130fb89c" title="Build variable -&gt; operator node lookup table using a single forward pass. The resulting sequence is m...">var2op()</a> [ which(values) ] ] &lt;- true</code> <br /></td></tr>
<tr class="separator:aadfbe9e7b9f8442b699fd1a6045eab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab92e0fa31904368a888aa95cc57a5fe5"><td class="memItemLeft" align="right" valign="top"><a id="ab92e0fa31904368a888aa95cc57a5fe5"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ab92e0fa31904368a888aa95cc57a5fe5">dep_index</a></td></tr>
<tr class="memdesc:ab92e0fa31904368a888aa95cc57a5fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers into <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code> determining <b>dependent</b> variables. <br /></td></tr>
<tr class="separator:ab92e0fa31904368a888aa95cc57a5fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18a96dd9424824d1469a1f2df118a39"><td class="memItemLeft" align="right" valign="top"><a id="ad18a96dd9424824d1469a1f2df118a39"></a>
std::vector&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ad18a96dd9424824d1469a1f2df118a39">derivs</a></td></tr>
<tr class="memdesc:ad18a96dd9424824d1469a1f2df118a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous workspace for derivatives (same length as <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code>) <br /></td></tr>
<tr class="separator:ad18a96dd9424824d1469a1f2df118a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60e4279c485af4515b724efca5928f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a4d60e4279c485af4515b724efca5928f">forward_compiled</a> )(Scalar *)</td></tr>
<tr class="memdesc:a4d60e4279c485af4515b724efca5928f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional pointer to compiled code.  <a href="#a4d60e4279c485af4515b724efca5928f">More...</a><br /></td></tr>
<tr class="separator:a4d60e4279c485af4515b724efca5928f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede927ad3fe17ba6afef5d303a4fcbb0"><td class="memItemLeft" align="right" valign="top"><a id="aede927ad3fe17ba6afef5d303a4fcbb0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#aede927ad3fe17ba6afef5d303a4fcbb0">in_use</a></td></tr>
<tr class="memdesc:aede927ad3fe17ba6afef5d303a4fcbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this glob present in the context stack? <br /></td></tr>
<tr class="separator:aede927ad3fe17ba6afef5d303a4fcbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f7bbdc201397934917936b67d407a"><td class="memItemLeft" align="right" valign="top"><a id="ab65f7bbdc201397934917936b67d407a"></a>
IndexVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ab65f7bbdc201397934917936b67d407a">inputs</a></td></tr>
<tr class="memdesc:ab65f7bbdc201397934917936b67d407a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers into <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code> determining operator inputs. <br /></td></tr>
<tr class="separator:ab65f7bbdc201397934917936b67d407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f37158b8f5271c5313b45e36bc7d2c"><td class="memItemLeft" align="right" valign="top"><a id="a79f37158b8f5271c5313b45e36bc7d2c"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a79f37158b8f5271c5313b45e36bc7d2c">inv_index</a></td></tr>
<tr class="memdesc:a79f37158b8f5271c5313b45e36bc7d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers into <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code> determining <b>independent</b> variables. <br /></td></tr>
<tr class="separator:a79f37158b8f5271c5313b45e36bc7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f7cc38f0893edccbfd5a603536685"><td class="memItemLeft" align="right" valign="top"><a id="ac67f7cc38f0893edccbfd5a603536685"></a>
<a class="el" href="structTMBad_1_1global_1_1operation__stack.html">operation_stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ac67f7cc38f0893edccbfd5a603536685">opstack</a></td></tr>
<tr class="memdesc:ac67f7cc38f0893edccbfd5a603536685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation stack. <br /></td></tr>
<tr class="separator:ac67f7cc38f0893edccbfd5a603536685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967af82378829c553645c98e038cd222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global.html">global</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a967af82378829c553645c98e038cd222">parent_glob</a></td></tr>
<tr class="memdesc:a967af82378829c553645c98e038cd222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Previous ad context to be restored then this context ends.  <a href="#a967af82378829c553645c98e038cd222">More...</a><br /></td></tr>
<tr class="separator:a967af82378829c553645c98e038cd222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561ba40f4d19d3e0a95519c6b63109ce"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#a561ba40f4d19d3e0a95519c6b63109ce">reverse_compiled</a> )(Scalar *, Scalar *)</td></tr>
<tr class="memdesc:a561ba40f4d19d3e0a95519c6b63109ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional pointer to compiled code.  <a href="#a561ba40f4d19d3e0a95519c6b63109ce">More...</a><br /></td></tr>
<tr class="separator:a561ba40f4d19d3e0a95519c6b63109ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e103e381a0ac01787adda6ff0e12d1"><td class="memItemLeft" align="right" valign="top"><a id="ab0e103e381a0ac01787adda6ff0e12d1"></a>
std::vector&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1">values</a></td></tr>
<tr class="memdesc:ab0e103e381a0ac01787adda6ff0e12d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous workspace for taped variables (same length as <code><a class="el" href="structTMBad_1_1global.html#ad18a96dd9424824d1469a1f2df118a39" title="Contiguous workspace for derivatives (same length as global::values) ">global::derivs</a></code>) <br /></td></tr>
<tr class="separator:ab0e103e381a0ac01787adda6ff0e12d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Struct defining the main AD context. </p>
<ul>
<li>An AD context holds the three data arrays defining the tape: <code>opstack</code>, <code>inputs</code> and <code>values</code>.</li>
<li>An AD context can be activated (set global) using <code><a class="el" href="structTMBad_1_1global.html#a4a2d146e97f051dc2a4ae2de004d64e7" title="Enable ad calulations to be piped to this glob. ">ad_start()</a></code> or inactivated using <code><a class="el" href="structTMBad_1_1global.html#a576ac1ed235900325b0b6d216973397b" title="Stop ad calculations from being piped to this glob. ">ad_stop()</a></code>.</li>
<li><code><a class="el" href="namespaceTMBad.html#a2fddc8982f018c5d05469d1afda89529" title="Get pointer to current global AD context (or NULL if no context is active). ">get_glob()</a></code> gives a pointer to the current active AD context.</li>
<li>AD contexts can be started and stopped while others are running (nested AD contexts).</li>
<li>An AD context has a unique parent context. The <em>context stack</em> is defined as the recursive parent traversal from <code><a class="el" href="namespaceTMBad.html#a2fddc8982f018c5d05469d1afda89529" title="Get pointer to current global AD context (or NULL if no context is active). ">get_glob()</a></code> (top) to <code>NULL</code> (bottom). </li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l00797">797</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a2d146e97f051dc2a4ae2de004d64e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2d146e97f051dc2a4ae2de004d64e7">&sect;&nbsp;</a></span>ad_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::ad_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable ad calulations to be piped to this glob. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to start the same ad context several times </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l02065">2065</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">TMBad::accumulation_tree_split()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a7f57af25a9111396b79937cccc113710">TMBad::ADFun&lt;&gt;::ADFun()</a>, and <a class="el" href="structTMBad_1_1ADFun.html#a7eaf97afbbf35a63d2895b12a18391ce">TMBad::ADFun&lt;&gt;::decompose()</a>.</p>

</div>
</div>
<a id="a23e8e93a598108e047a1fa68bb9a0cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e8e93a598108e047a1fa68bb9a0cf6">&sect;&nbsp;</a></span>build_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1graph.html">graph</a> TMBad::global::build_graph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a graph-representation of the operation stack. </p>
<p>The graph is defined as follows:</p><ul>
<li>Nodes are operators i.e., the number of nodes is <code>opstack.size()</code></li>
<li>A connection from Op1 to Op2 is present &lt;==&gt; there exists a <em>variable</em> which is input to Op2 and output from Op1 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transpose</td><td>Flag to reverse all edges. </td></tr>
    <tr><td class="paramname">keep_var</td><td>Boolean mask of <em>variables</em> to be considered as potential edges. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01525">1525</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a29518fc35dd8f9c733a51739aac7786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29518fc35dd8f9c733a51739aac7786c">&sect;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all workspace without actually freeing the workspace. </p>
<dl class="section note"><dt>Note</dt><dd>Intended use: <b>retaping</b> without re-allocating </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00962">962</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="ad0d7d23b96392bb9f92a0799a26a874f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d7d23b96392bb9f92a0799a26a874f">&sect;&nbsp;</a></span>clear_array_subgraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::clear_array_subgraph </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Vector::value_type&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Vector::value_type(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic clear array along global::subgraph. </p>
<p>Applicable for</p><ul>
<li>std::vector&lt;Scalar&gt;</li>
<li>std::vector&lt;Replay&gt;</li>
<li>std::vector&lt;bool&gt; <dl class="section note"><dt>Note</dt><dd>This function calls <code><a class="el" href="structTMBad_1_1global.html#af792c941af51a329f7c855c5a491909b" title="Cache array pointers required by all subgraph routines. ">subgraph_cache_ptr()</a></code>. It follows that complexity is proportional to the full graph for the first call. Following calls have complexity proportional to the subgraph. </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l01076">1076</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="a90fbfe5560ea16ec5102823153517a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fbfe5560ea16ec5102823153517a50">&sect;&nbsp;</a></span>clear_deriv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::clear_deriv </td>
          <td>(</td>
          <td class="paramtype">Position&#160;</td>
          <td class="paramname"><em>start</em> = <code>Position(0,&#160;0,&#160;0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set derivatives to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Specify 'tail sweep' starting from this position </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00984">984</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">TMBad::accumulation_tree_split()</a>, and <a class="el" href="structTMBad_1_1ADFun.html#a51f479248e7946fb628f816a82f95c26">TMBad::ADFun&lt;&gt;::Jacobian()</a>.</p>

</div>
</div>
<a id="a9c75e4a0c3c3b2cfab165b03881ef5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c75e4a0c3c3b2cfab165b03881ef5d7">&sect;&nbsp;</a></span>clear_deriv_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::clear_deriv_sub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear derivative array along a subgraph. </p>
<p>Clear all <em>relevant</em> input variable derivatives by noting that each such <em>input</em> variable must also be an <em>output</em> of some operator node. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01269">1269</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#a0871d6dd74d0785383a352ef419c54a2">TMBad::ADFun&lt;&gt;::Jacobian()</a>.</p>

</div>
</div>
<a id="aec6a949ba45e07c3011c0452693fc054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6a949ba45e07c3011c0452693fc054">&sect;&nbsp;</a></span>eliminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::eliminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Very simple tape optimizer. </p>
<p>The tape optimizer attempts to remove variables unless they are</p><ul>
<li>Direct input variables</li>
<li>Direct output variables</li>
<li>Variables that affect the output variables. <dl class="section warning"><dt>Warning</dt><dd>Sparse operators can have input variables that are marked for removal while at the same time having input variables that must be kept. In this case the redundant input variables are remapped to an arbitrary variable (number zero - see <code><a class="el" href="structTMBad_1_1global.html#af96198fbf4f41e224f9ac150a6e99344" title="Extract a subgraph as a new global object. Fast when called many times. ">global::extract_sub</a></code>). Formally this is correct but in practice it could result in nan function evaluations (Example: Vectorized log function with negative values of <code>x[0]</code>). </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01747">1747</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">TMBad::accumulation_tree_split()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a7eaf97afbbf35a63d2895b12a18391ce">TMBad::ADFun&lt;&gt;::decompose()</a>, and <a class="el" href="structTMBad_1_1ADFun.html#a782cbf6958519f6ceb33816c02631c97">TMBad::ADFun&lt;&gt;::eliminate()</a>.</p>

</div>
</div>
<a id="af96198fbf4f41e224f9ac150a6e99344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96198fbf4f41e224f9ac150a6e99344">&sect;&nbsp;</a></span>extract_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1global.html">global</a> TMBad::global::extract_sub </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_remap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a>&#160;</td>
          <td class="paramname"><em>new_glob</em> = <code><a class="el" href="structTMBad_1_1global.html">global</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a subgraph as a new global object. Fast when called many times. </p>
<p>Sub-graph can either be <em>sorted</em> (common case) or just topologically sorted* (e.g. for graph permutations). In both cases the subgraph may or may not include all independent/dependent variables.</p>
<p>It's important to note that this routine permutes <code>inv_index</code> and <code>dep_index</code> to reflect the original parameter order (which is only relevant in the un-sorted case). FIXME: Correct the code!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_remap</td><td>Workspace containing garbage on output. Can be used to avoid re-allocating. </td></tr>
    <tr><td class="paramname">new_glob</td><td>Target of extraction. Empty by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity proportional to subgraph <b>if workspace is allocated</b>. Otherwise proportional to full graph. </dd>
<dd>
<code>global::subgraph_seq</code> must be calculated in advance. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FIXME: Must copy the dynamic operator table by default At least two applications of this function:<ul>
<li>Tape optimizer. Here we want to delete the old glob after extraction.</li>
<li>Fast quadrature. Here we want to keep the old glob. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A non-empty extraction target <code>new_glob</code> may be useful for function slicing. </dd>
<dd>
Special attention must be payed to variables that affect the subgraph trajectory without being part of the trajectory. These <em>boundary</em> variables can be remapped (using <code>var_remap</code>) prior to calling this function. Note that by default boundary variables are remapped to an arbitrary variable (the first variable <code>values[0]</code>). </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01271">1271</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1autopar.html#ac5cb220e781af8a02e6a43ea0fd7a3b6">TMBad::autopar::extract()</a>, <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">TMBad::reorder_depth_first()</a>, and <a class="el" href="namespaceTMBad.html#aeadfc2a73d19ae22613af3cd3ed203f6">TMBad::reorder_temporaries()</a>.</p>

</div>
</div>
<a id="aaa6b8b5744ae25b8c0a1e47a3b6c2e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6b8b5744ae25b8c0a1e47a3b6c2e08">&sect;&nbsp;</a></span>extract_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1global.html">global</a> TMBad::global::extract_sub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a subgraph as a new global object. Slow when called many times. </p>
<dl class="section note"><dt>Note</dt><dd><code>global::subgraph_seq</code> must be calculated in advance. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01404">1404</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a6e0be543105b173bdab6874ab3479190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0be543105b173bdab6874ab3479190">&sect;&nbsp;</a></span>extract_sub_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::extract_sub_inplace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>marks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place subgraph extractor. </p>
<p>Slower, but more memory efficient, than <code>extract_sub</code>. Subset is by boolean marked <b>variables</b> rather than actual subgraph nodes. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01320">1320</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="aef2700550d94c96c7a2b437354fac8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2700550d94c96c7a2b437354fac8d7">&sect;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::forward </td>
          <td>(</td>
          <td class="paramtype">Position&#160;</td>
          <td class="paramname"><em>start</em> = <code>Position(0,&#160;0,&#160;0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full or partial forward sweep through the operation stack. Updates <code><a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Specify 'tail sweep' starting from this position </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01005">1005</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">TMBad::accumulation_tree_split()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a05bb7fc1f61fedeb107ac8d34196d336">TMBad::ADFun&lt;&gt;::activeRange()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a51f479248e7946fb628f816a82f95c26">TMBad::ADFun&lt;&gt;::Jacobian()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a9ff43050c6be823934480dd817d93339">TMBad::ADFun&lt;&gt;::operator()()</a>, and <a class="el" href="structTMBad_1_1sequential__reduction.html#af1e29eb57afd6a9280e5269cbbde12e1">TMBad::sequential_reduction::sequential_reduction()</a>.</p>

</div>
</div>
<a id="a455b14752a03b03770a543af16daaf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455b14752a03b03770a543af16daaf38">&sect;&nbsp;</a></span>forward_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::forward_dense </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>marks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full forward dependency sweep through the operation stack. </p>
<p>For each operator mark <em>all</em> outputs if <em>any</em> inputs are marked. The intended use of this function is to determine a valid (complete topoligically sorted) subgraph. </p><dl class="section note"><dt>Note</dt><dd>A reverse version of this function seems less useful so we do not yet provide it. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FIXME Indirect dependencies are not yet accounted for. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01066">1066</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a7dc1e113f676e1f266a1e86c32af6ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1e113f676e1f266a1e86c32af6ef8">&sect;&nbsp;</a></span>forward_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1graph.html">graph</a> TMBad::global::forward_graph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>keep_var</em> = <code>std::vector&lt;bool&gt;(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct operator graph with forward connections. </p>
<p>See <code><a class="el" href="structTMBad_1_1global.html#a23e8e93a598108e047a1fa68bb9a0cf6" title="Build a graph-representation of the operation stack. ">build_graph()</a></code> </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01576">1576</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1sequential__reduction.html#af1e29eb57afd6a9280e5269cbbde12e1">TMBad::sequential_reduction::sequential_reduction()</a>.</p>

</div>
</div>
<a id="a97b377010b34268039733176938d51c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b377010b34268039733176938d51c0">&sect;&nbsp;</a></span>forward_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardArgs , class NodeFilter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::forward_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeFilter &amp;&#160;</td>
          <td class="paramname"><em>node_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic forward sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Skip operators up to this point. </td></tr>
    <tr><td class="paramname">node_filter</td><td>Skip operators not in this mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Don't forget to set <code>args.ptr</code> when using <code>begin</code>. </dd></dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l01010">1010</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="a1e68a680c2059a12235247e82eab79d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e68a680c2059a12235247e82eab79d4">&sect;&nbsp;</a></span>forward_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::forward_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic forward sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Skip operators up to this point. </td></tr>
    <tr><td class="paramname">node_filter</td><td>Skip operators not in this mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Don't forget to set <code>args.ptr</code> when using <code>begin</code>. </dd></dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l01021">1021</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="a8b3a5ad844e2088bb90c4aef16f631fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3a5ad844e2088bb90c4aef16f631fd">&sect;&nbsp;</a></span>forward_replay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::forward_replay </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inv_tags</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dep_tags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replay this operation sequence to itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inv_tags</td><td>Keep independent variable tags? </td></tr>
    <tr><td class="paramname">dep_tags</td><td>Keep dependent variable tags? </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01221">1221</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#a9136db7013fac131a8b3c07255315f6a">TMBad::ADFun&lt;&gt;::replay()</a>.</p>

</div>
</div>
<a id="afde93efaa23b72a4c006d8f2ffa2b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde93efaa23b72a4c006d8f2ffa2b81a">&sect;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_t TMBad::global::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple hash code of tape. </p>
<p>The hash function has the following properties:</p><ul>
<li>If x and y have different hash codes then x and y are <b>not</b> <code><a class="el" href="structTMBad_1_1global.html#a7257275d5fbfbc0f6a8ef8bc1227cbb9" title="Test if two tapes are identical. ">identical()</a></code>.</li>
<li>If x and y have equal hash codes then x and y are <b>likely</b> <code><a class="el" href="structTMBad_1_1global.html#a7257275d5fbfbc0f6a8ef8bc1227cbb9" title="Test if two tapes are identical. ">identical()</a></code>. This situation must always be followed up by a collision test. </li>
</ul>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01621">1621</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a8c705966ba5c49c15bc2613ced3768aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c705966ba5c49c15bc2613ced3768aa">&sect;&nbsp;</a></span>hash_sweep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hash_t &gt; TMBad::global::hash_sweep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global_1_1hash__config.html">hash_config</a>&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate hash codes of each dependent variable using a single forward sweep. </p>
<p>The hash function has the following properties:</p><ul>
<li>If x and y have different hash codes then x and y are <b>not</b> <code><a class="el" href="structTMBad_1_1global.html#a7257275d5fbfbc0f6a8ef8bc1227cbb9" title="Test if two tapes are identical. ">identical()</a></code>.</li>
<li><p class="startli">If x and y have equal hash codes then x and y are <b>likely</b> <code><a class="el" href="structTMBad_1_1global.html#a7257275d5fbfbc0f6a8ef8bc1227cbb9" title="Test if two tapes are identical. ">identical()</a></code>. This situation must always be followed up by a collision test.</p>
<p class="startli">In the <b>weak</b> case the hash codes attempt to discriminate between <em>mappings</em>. In the <b>strong</b> case the hash codes discriminate between sub-expressions. For example consider the computational graph of</p>
<p class="startli">(x1+x2) * (x3+x4)</p>
<p class="startli">In the weak case (x1+x2) and (x3+x4) are considered identical because the mappings f(x1,x2)=x1+x2 and f(x3,x4)=x3+x4 are identical. If, in addition, the mappings are evaluated at the exact same arguments then they are identical in the strong sense (equal sub-expressions).</p>
<p class="startli">The hash function works as follows. Starting out with a scalar hash update function <code>hash(x,h)</code> we generalize to vectors using the recursion</p>
<p class="startli"><code>hash(x_1,...,x_n) := hash(x_1, hash(x_2,...,x_n) )</code></p>
<p class="startli">Hash codes of the operation</p>
<p class="startli"><code>(y_1,...,y_m) = f(x_1,...,x_n)</code></p>
<p class="startli">are defined as</p>
<p class="startli"><code>hash(y_k) = hash(f, x_1, ..., x_n) + k - 1</code></p>
<p class="startli">assuming <code>f</code> is represented by its <code><a class="el" href="structTMBad_1_1global_1_1OperatorPure.html#a112474b01b04462a0819883905824932" title="Operator identifier. ">OperatorPure::identifier()</a></code>.</p>
<p class="startli">Note, that dynamic operators by default have a unique identifier (their memory address). It follows that the hash code of output variables are (<em>very</em> likely) unique as well.</p>
<p class="startli">For the reason above, it may seem tempting to skip input hashing completely in the dynamic operator case. However, that won't work because we allow dynamic operators to have a static identifier, see <code><a class="el" href="structTMBad_1_1global_1_1Operator.html#afe8ae701c2bf31311cee3ea27cd918e6" title="Should this operator have a static identifier ? ">Operator::add_static_identifier</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weak</td><td>If <code>true</code> calculate weak hash codes. Otherwise strong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In the weak case a vector of same length as the number of dependent variables. In the strong case return the entire vector of variable hash codes (same length as <code>values</code>). </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01659">1659</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1autopar.html#affc4054e7794b8a919ba0742f27e0a93">TMBad::autopar::output_size()</a>, and <a class="el" href="namespaceTMBad.html#a1b45e31a4e1f8a7839d2540965259543">TMBad::reorder_sub_expressions()</a>.</p>

</div>
</div>
<a id="a7257275d5fbfbc0f6a8ef8bc1227cbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7257275d5fbfbc0f6a8ef8bc1227cbb9">&sect;&nbsp;</a></span>identical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TMBad::global::identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if two tapes are identical. </p>
<p>We say that two tapes are identical if the same input is guarantied to result in the same output. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01592">1592</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a463cc358b18ec2160cab32a0dcfab95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463cc358b18ec2160cab32a0dcfab95c">&sect;&nbsp;</a></span>op2idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; TMBad::global::op2idx </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>NA</em> = <code>(Index)-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General operator -&gt; variable table generator. </p>
<p>For each operator match its output variable in a given subset of variables. If a match exists return the index of the match, otherwise return a missing value code. If several matches exist, return the index corresponding to the <em>first match</em> from the left. </p><dl class="section note"><dt>Note</dt><dd>Size of this table is <code>opstack.size()</code>. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01462">1462</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1autopar.html#ac5cb220e781af8a02e6a43ea0fd7a3b6">TMBad::autopar::extract()</a>, and <a class="el" href="structTMBad_1_1sequential__reduction.html#af1e29eb57afd6a9280e5269cbbde12e1">TMBad::sequential_reduction::sequential_reduction()</a>.</p>

</div>
</div>
<a id="ae1e6551f3ec84d73282701db0d6c6df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e6551f3ec84d73282701db0d6c6df9">&sect;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::reverse </td>
          <td>(</td>
          <td class="paramtype">Position&#160;</td>
          <td class="paramname"><em>start</em> = <code>Position(0,&#160;0,&#160;0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full or partial reverse sweep through the operation stack. Updates <code><a class="el" href="structTMBad_1_1global.html#ad18a96dd9424824d1469a1f2df118a39" title="Contiguous workspace for derivatives (same length as global::values) ">global::derivs</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Specify 'tail sweep' starting from this position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A reverse tail sweep through nodes <code>opstack[start:end]</code> will in general affect the derivative array outside the desired range, i.e. the derivative array should be considered as invalidated for indices smaller than <code>start.ptr.second</code>. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01015">1015</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">TMBad::accumulation_tree_split()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a167b014b2dd4b054479793a34ec8f15a">TMBad::ADFun&lt;&gt;::activeDomain()</a>, <a class="el" href="namespaceTMBad.html#af5a6038cd6873a41e51cd770137727bf">TMBad::get_accumulation_tree()</a>, and <a class="el" href="structTMBad_1_1ADFun.html#a51f479248e7946fb628f816a82f95c26">TMBad::ADFun&lt;&gt;::Jacobian()</a>.</p>

</div>
</div>
<a id="ac88d0db54d389ed8a6950df570749258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88d0db54d389ed8a6950df570749258">&sect;&nbsp;</a></span>reverse_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1graph.html">graph</a> TMBad::global::reverse_graph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>keep_var</em> = <code>std::vector&lt;bool&gt;(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct operator graph with reverse connections. </p>
<p>See <code><a class="el" href="structTMBad_1_1global.html#a23e8e93a598108e047a1fa68bb9a0cf6" title="Build a graph-representation of the operation stack. ">build_graph()</a></code> </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01584">1584</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#a0871d6dd74d0785383a352ef419c54a2">TMBad::ADFun&lt;&gt;::Jacobian()</a>, and <a class="el" href="structTMBad_1_1sequential__reduction.html#af1e29eb57afd6a9280e5269cbbde12e1">TMBad::sequential_reduction::sequential_reduction()</a>.</p>

</div>
</div>
<a id="a5773910a9aa186762830a4d8a63a827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5773910a9aa186762830a4d8a63a827f">&sect;&nbsp;</a></span>reverse_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReverseArgs , class NodeFilter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::reverse_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeFilter &amp;&#160;</td>
          <td class="paramname"><em>node_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic reverse sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_filter</td><td>Skip operators not in this mask. </td></tr>
    <tr><td class="paramname">begin</td><td>Skip operators up to this point. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l01029">1029</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="acfe279cafb56f4e47cd1ebc26e602198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe279cafb56f4e47cd1ebc26e602198">&sect;&nbsp;</a></span>reverse_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReverseArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::reverse_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic reverse sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_filter</td><td>Skip operators not in this mask. </td></tr>
    <tr><td class="paramname">begin</td><td>Skip operators up to this point. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l01041">1041</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="acfd2add8d83e70d9aa5fd2853afde922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd2add8d83e70d9aa5fd2853afde922">&sect;&nbsp;</a></span>set_fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::set_fuse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable operator fusion. </p>
<p>This function is applicable if <a class="el" href="namespaceTMBad.html" title="Automatic differentiation library designed for TMB. ">TMBad</a> has been compiled with the preprocessor flag <code>-DFUSE</code>. The function sets/unsets the <em>global</em> <code>fuse</code> flag. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01929">1929</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="aa63eb6061e7c2a714cb2975f361793ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63eb6061e7c2a714cb2975f361793ab">&sect;&nbsp;</a></span>set_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::set_subgraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>marks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert selected variables to a subgraph sequence. </p>
<p>For each variable check if the variable is marked. If yes add the (unique) operator, that generated the variable as its result, to the subgraph sequence. Although an operator can generate multiple variables it is guarantied that an operator is only added once. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01241">1241</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a0ef0eb94e36d9b140bf271d7a94e00c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef0eb94e36d9b140bf271d7a94e00c4">&sect;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::shrink_to_fit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>.9</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release unnecessary workspace to the system. </p>
<p>In contrast to <code>clear</code> this method does not destroy the object. Its intended use is to be called before and/or after a memory intensive routine, e.g. <code>global::optimize</code> or <code><a class="el" href="structTMBad_1_1global.html#a23e8e93a598108e047a1fa68bb9a0cf6" title="Build a graph-representation of the operation stack. ">global::build_graph</a></code>. The function attempts to shrink the workspace of the most critical containers:</p><ul>
<li><code>derivs</code> is freed completely.</li>
<li><code>subgraph_ptr</code> is freed completely.</li>
<li><code>values</code> is reduced if the potential relative reduction is 'significant'.</li>
<li><code>inputs</code> is reduced if the potential relative reduction is 'significant'. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>Number between zero and one. A reduction is considered 'significant' if it is at least <code>1-tol</code>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00973">973</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">TMBad::reorder_depth_first()</a>.</p>

</div>
</div>
<a id="af792c941af51a329f7c855c5a491909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af792c941af51a329f7c855c5a491909b">&sect;&nbsp;</a></span>subgraph_cache_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::global::subgraph_cache_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache array pointers required by all subgraph routines. </p>
<dl class="section note"><dt>Note</dt><dd>Requires a sweep through the full computational graph. In addition a workspace of <code>sizeof(IndexPair) * opstack.size()</code> is allocated. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01230">1230</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#af1eaffa26abd798259f48bd225838090">TMBad::remap_identical_sub_expressions()</a>, <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">TMBad::reorder_depth_first()</a>, <a class="el" href="structTMBad_1_1sequential__reduction.html#af1e29eb57afd6a9280e5269cbbde12e1">TMBad::sequential_reduction::sequential_reduction()</a>, and <a class="el" href="namespaceTMBad.html#a7f273488d2199251bb0ffd0bc51e770c">TMBad::split_period()</a>.</p>

</div>
</div>
<a id="a5a6e54800e85e7f29d5e82dd130fb89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6e54800e85e7f29d5e82dd130fb89c">&sect;&nbsp;</a></span>var2op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; TMBad::global::var2op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build variable -&gt; operator node lookup table using a single forward pass. The resulting sequence is monotonically increasing. </p>
<p>For each variable (i.e. pointer into <a class="el" href="structTMBad_1_1global.html#ab0e103e381a0ac01787adda6ff0e12d1" title="Contiguous workspace for taped variables (same length as global::derivs) ">global::values</a>) find operator (i.e. pointer into <a class="el" href="structTMBad_1_1global.html#ac67f7cc38f0893edccbfd5a603536685" title="Operation stack. ">global::opstack</a>) that generated the variable as its results. </p><dl class="section note"><dt>Note</dt><dd>Size of this table is <code>values.size()</code>. </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l01409">1409</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#a35c4a932098d7dcf09166961971a9777">TMBad::ADFun&lt;&gt;::decompose_refs()</a>, <a class="el" href="namespaceTMBad.html#af5a6038cd6873a41e51cd770137727bf">TMBad::get_accumulation_tree()</a>, <a class="el" href="namespaceTMBad.html#af1eaffa26abd798259f48bd225838090">TMBad::remap_identical_sub_expressions()</a>, <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">TMBad::reorder_depth_first()</a>, <a class="el" href="namespaceTMBad.html#aeadfc2a73d19ae22613af3cd3ed203f6">TMBad::reorder_temporaries()</a>, and <a class="el" href="namespaceTMBad.html#a044720b04dcd5e9104166ec491c83719">TMBad::reverse_boundary()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4d60e4279c485af4515b724efca5928f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d60e4279c485af4515b724efca5928f">&sect;&nbsp;</a></span>forward_compiled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* TMBad::global::forward_compiled) (Scalar *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional pointer to compiled code. </p>
<dl class="section warning"><dt>Warning</dt><dd>Experimental </dd></dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l00956">956</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<a id="a967af82378829c553645c98e038cd222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967af82378829c553645c98e038cd222">&sect;&nbsp;</a></span>parent_glob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1global.html">global</a>* TMBad::global::parent_glob</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previous ad context to be restored then this context ends. </p>
<p>The value <code>NULL</code> signifies that either</p><ul>
<li>this glob is not in use <b>or</b></li>
<li>this glob is the first in the context stack </li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l02763">2763</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1global_1_1ad__aug.html#a6a6aa7ba7640654cc12ce297121a230c">TMBad::global::ad_aug::in_context_stack()</a>.</p>

</div>
</div>
<a id="a561ba40f4d19d3e0a95519c6b63109ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561ba40f4d19d3e0a95519c6b63109ce">&sect;&nbsp;</a></span>reverse_compiled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* TMBad::global::reverse_compiled) (Scalar *, Scalar *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional pointer to compiled code. </p>
<dl class="section warning"><dt>Warning</dt><dd>Experimental </dd></dl>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l00958">958</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="global_8hpp_source.html">global.hpp</a></li>
<li><a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a></li>
</ul>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
