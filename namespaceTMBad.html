<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: TMBad Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.9.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TMBad Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Automatic differentiation library designed for TMB.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ad__plain__index.html">ad_plain_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <code>ad_plain</code> from index.  <a href="structTMBad_1_1ad__plain__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1adaptive.html">adaptive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable weak comparison operators of an ad type.  <a href="structTMBad_1_1adaptive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ADFun.html">ADFun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic differentiation function object.  <a href="structTMBad_1_1ADFun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ADFun__packed.html">ADFun_packed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of <a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">ADFun</a> object with packed input and output.  <a href="structTMBad_1_1ADFun__packed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1Args.html">Args</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument class to handle array access of operator inputs and outputs.  <a href="structTMBad_1_1Args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1AtomOp.html">AtomOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic checkpoint operator.  <a href="structTMBad_1_1AtomOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1autopar.html">autopar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a computational graph using a simple heuristic.  <a href="structTMBad_1_1autopar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1clique.html">clique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilility class for <code><a class="el" href="structTMBad_1_1sequential__reduction.html" title="Sequential reduction algorithm. ">sequential_reduction</a></code>.  <a href="structTMBad_1_1clique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1control.html">control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User control parameters for R's integrate.  <a href="structTMBad_1_1control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1Decomp2.html">Decomp2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposition of computational graph.  <a href="structTMBad_1_1Decomp2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1Decomp3.html">Decomp3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposition of computational graph.  <a href="structTMBad_1_1Decomp3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1forbid__remap.html">forbid_remap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forbid remappings if not consecutive.  <a href="structTMBad_1_1forbid__remap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ForwardArgs.html">ForwardArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access input/output values during a forward pass. Write access granted for the output value only.  <a href="structTMBad_1_1ForwardArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1global.html">global</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct defining the main AD context.  <a href="structTMBad_1_1global.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1graph.html">graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator graph in compressed row storage.  <a href="structTMBad_1_1graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1IndirectAccessor.html">IndirectAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <em>inplace</em> read access to value <em>or</em> derivative arrays.  <a href="structTMBad_1_1IndirectAccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1Integral.html">Integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to R's adaptive integrate routine.  <a href="structTMBad_1_1Integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1intervals.html">intervals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of closed intervals.  <a href="structTMBad_1_1intervals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1multivariate__index.html">multivariate_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilility class for <code><a class="el" href="structTMBad_1_1sequential__reduction.html" title="Sequential reduction algorithm. ">sequential_reduction</a></code>.  <a href="structTMBad_1_1multivariate__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1mvIntegral.html">mvIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate integral class.  <a href="structTMBad_1_1mvIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1old__state.html">old_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current tape's state and restore it on request.  <a href="structTMBad_1_1old__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1omp__shared__ptr.html">omp_shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage shared operator data across multiple threads.  <a href="structTMBad_1_1omp__shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1op__info.html">op_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise collection of selected operator flags.  <a href="structTMBad_1_1op__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1PackOp.html">PackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack (<code><a class="el" href="structTMBad_1_1PackOp.html" title="Pack (PackOp) or unpack (UnpkOp) n consecutive values on the tape. ">PackOp</a></code>) or unpack (<code><a class="el" href="structTMBad_1_1UnpkOp.html" title="Pack (PackOp) or unpack (UnpkOp) n consecutive values on the tape. ">UnpkOp</a></code>) <code>n</code> consecutive values on the tape.  <a href="structTMBad_1_1PackOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1PackWrap.html">PackWrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a functor to have packed input/output.  <a href="structTMBad_1_1PackWrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ParalOp.html">ParalOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel operator.  <a href="structTMBad_1_1ParalOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ParametersChanged.html">ParametersChanged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tester for <code><a class="el" href="structTMBad_1_1retaping__derivative__table.html" title="Adaptive derivative table used by AtomOp ">retaping_derivative_table</a></code>.  <a href="structTMBad_1_1ParametersChanged.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1period.html">period</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a period in a sequence.  <a href="structTMBad_1_1period.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1periodic.html">periodic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period analyzer.  <a href="structTMBad_1_1periodic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1retaping__derivative__table.html">retaping_derivative_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive derivative table used by <code><a class="el" href="structTMBad_1_1AtomOp.html" title="Generic checkpoint operator. ">AtomOp</a></code>  <a href="structTMBad_1_1retaping__derivative__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1ReverseArgs.html">ReverseArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access input/output values and derivatives during a reverse pass. Write access granted for the input derivative only.  <a href="structTMBad_1_1ReverseArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1segment__ref.html">segment_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide read/write access to an array segment.  <a href="structTMBad_1_1segment__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1SegmentRef.html">SegmentRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <em>specific</em> contiguous set of values on a <em>specific</em> tape.  <a href="structTMBad_1_1SegmentRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1sequential__reduction.html">sequential_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential reduction algorithm.  <a href="structTMBad_1_1sequential__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1SpJacFun__config.html">SpJacFun_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration parameters for SpJacFun()  <a href="structTMBad_1_1SpJacFun__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1sr__grid.html">sr_grid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilility class for <code><a class="el" href="structTMBad_1_1sequential__reduction.html" title="Sequential reduction algorithm. ">sequential_reduction</a></code>.  <a href="structTMBad_1_1sr__grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1standard__derivative__table.html">standard_derivative_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed derivative table used by <code><a class="el" href="structTMBad_1_1AtomOp.html" title="Generic checkpoint operator. ">AtomOp</a></code>  <a href="structTMBad_1_1standard__derivative__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1StdWrap.html">StdWrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interoperability with other vector classes.  <a href="structTMBad_1_1StdWrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTMBad_1_1UnpkOp.html">UnpkOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack (<code><a class="el" href="structTMBad_1_1PackOp.html" title="Pack (PackOp) or unpack (UnpkOp) n consecutive values on the tape. ">PackOp</a></code>) or unpack (<code><a class="el" href="structTMBad_1_1UnpkOp.html" title="Pack (PackOp) or unpack (UnpkOp) n consecutive values on the tape. ">UnpkOp</a></code>) <code>n</code> consecutive values on the tape.  <a href="structTMBad_1_1UnpkOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac58fdbf4882a18362578c1727898df5c"><td class="memItemLeft" align="right" valign="top"><a id="ac58fdbf4882a18362578c1727898df5c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ac58fdbf4882a18362578c1727898df5c">ArrayAccess</a> <tr class="memdesc:ac58fdbf4882a18362578c1727898df5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define <code>segment_ref</code> array to access inside <code>ForwardArgs</code> or <code>ReverseArgs</code> <br /></td></tr>
</td></tr>
<tr class="separator:ac58fdbf4882a18362578c1727898df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab170ef212115e6d82d5df72afc3d6342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global.html">global</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">accumulation_tree_split</a> (<a class="el" href="structTMBad_1_1global.html">global</a> glob, bool sum_=false)</td></tr>
<tr class="memdesc:ab170ef212115e6d82d5df72afc3d6342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a computational graph by it's accumulation tree.  <a href="#ab170ef212115e6d82d5df72afc3d6342">More...</a><br /></td></tr>
<tr class="separator:ab170ef212115e6d82d5df72afc3d6342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942995be599665e0914b3367c75e3cd"><td class="memTemplParams" colspan="2">template&lt;class Functor , class Test  = ParametersChanged&gt; </td></tr>
<tr class="memitem:a8942995be599665e0914b3367c75e3cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1ADFun.html">ADFun</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a8942995be599665e0914b3367c75e3cd">ADFun_retaping</a> (Functor &amp;F, const std::vector&lt; <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &gt; &amp;x, Test test=Test())</td></tr>
<tr class="memdesc:a8942995be599665e0914b3367c75e3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">ADFun</a> that automatically retapes.  <a href="#a8942995be599665e0914b3367c75e3cd">More...</a><br /></td></tr>
<tr class="separator:a8942995be599665e0914b3367c75e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378f5a84861c70994f30a12b9e2b7f47"><td class="memTemplParams" colspan="2">template&lt;class Functor , class Test &gt; </td></tr>
<tr class="memitem:a378f5a84861c70994f30a12b9e2b7f47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1ADFun__packed.html">ADFun_packed</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a378f5a84861c70994f30a12b9e2b7f47">ADFun_retaping</a> (Functor &amp;F, const std::vector&lt; <a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a> &gt; &amp;x, Test test)</td></tr>
<tr class="memdesc:a378f5a84861c70994f30a12b9e2b7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">ADFun</a> that automatically retapes.  <a href="#a378f5a84861c70994f30a12b9e2b7f47">More...</a><br /></td></tr>
<tr class="separator:a378f5a84861c70994f30a12b9e2b7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da8f10d11a2ebeb90e146372c438714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a9da8f10d11a2ebeb90e146372c438714">aggregate</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, int sign=1)</td></tr>
<tr class="memdesc:a9da8f10d11a2ebeb90e146372c438714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a multivariate output function by summing its range components.  <a href="#a9da8f10d11a2ebeb90e146372c438714">More...</a><br /></td></tr>
<tr class="separator:a9da8f10d11a2ebeb90e146372c438714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5dbfbcb2e6c7ca956e9032175ffc69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a7d5dbfbcb2e6c7ca956e9032175ffc69">all_allow_remap</a> (const <a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob)</td></tr>
<tr class="memdesc:a7d5dbfbcb2e6c7ca956e9032175ffc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if all operators in the stack allow input remapping.  <a href="#a7d5dbfbcb2e6c7ca956e9032175ffc69">More...</a><br /></td></tr>
<tr class="separator:a7d5dbfbcb2e6c7ca956e9032175ffc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c930c5983988be2a3c57322b23ebde"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a02c930c5983988be2a3c57322b23ebde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global_1_1ad__segment.html">global::ad_segment</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a02c930c5983988be2a3c57322b23ebde">contiguousBlock</a> (const Matrix &amp;x)</td></tr>
<tr class="memdesc:a02c930c5983988be2a3c57322b23ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a contiguous block on the tape.  <a href="#a02c930c5983988be2a3c57322b23ebde">More...</a><br /></td></tr>
<tr class="separator:a02c930c5983988be2a3c57322b23ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d169a0032feb2e2473c47a00f6bfcb"><td class="memItemLeft" align="right" valign="top"><a id="ae0d169a0032feb2e2473c47a00f6bfcb"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ae0d169a0032feb2e2473c47a00f6bfcb">find_op_by_name</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, const char *name)</td></tr>
<tr class="memdesc:ae0d169a0032feb2e2473c47a00f6bfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes by name. <br /></td></tr>
<tr class="separator:ae0d169a0032feb2e2473c47a00f6bfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc2a635fea773aff598ccbeaaacd074"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:adfc2a635fea773aff598ccbeaaacd074"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#adfc2a635fea773aff598ccbeaaacd074">forceContiguous</a> (V &amp;x)</td></tr>
<tr class="memdesc:adfc2a635fea773aff598ccbeaaacd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make contiguous ad vector.  <a href="#adfc2a635fea773aff598ccbeaaacd074">More...</a><br /></td></tr>
<tr class="separator:adfc2a635fea773aff598ccbeaaacd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a6038cd6873a41e51cd770137727bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#af5a6038cd6873a41e51cd770137727bf">get_accumulation_tree</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, bool boundary=false)</td></tr>
<tr class="memdesc:af5a6038cd6873a41e51cd770137727bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node indices of the accumulation tree or its boundary.  <a href="#af5a6038cd6873a41e51cd770137727bf">More...</a><br /></td></tr>
<tr class="separator:af5a6038cd6873a41e51cd770137727bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fddc8982f018c5d05469d1afda89529"><td class="memItemLeft" align="right" valign="top"><a id="a2fddc8982f018c5d05469d1afda89529"></a>
<a class="el" href="structTMBad_1_1global.html">global</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a2fddc8982f018c5d05469d1afda89529">get_glob</a> ()</td></tr>
<tr class="memdesc:a2fddc8982f018c5d05469d1afda89529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to current global AD context (or NULL if no context is active). <br /></td></tr>
<tr class="separator:a2fddc8982f018c5d05469d1afda89529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0907fd10ecf16de43870745c81f7d72b"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0907fd10ecf16de43870745c81f7d72b"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a0907fd10ecf16de43870745c81f7d72b">getContiguous</a> (const V &amp;x)</td></tr>
<tr class="memdesc:a0907fd10ecf16de43870745c81f7d72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contiguous (deep) copy of this vector.  <a href="#a0907fd10ecf16de43870745c81f7d72b">More...</a><br /></td></tr>
<tr class="separator:a0907fd10ecf16de43870745c81f7d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c73a21ac1632b2dfaff8a3e0aa405a"><td class="memTemplParams" colspan="2">template&lt;class Integrand &gt; </td></tr>
<tr class="memitem:ac1c73a21ac1632b2dfaff8a3e0aa405a"><td class="memTemplItemLeft" align="right" valign="top">Integrand::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ac1c73a21ac1632b2dfaff8a3e0aa405a">integrate</a> (Integrand f, typename Integrand::Scalar a=-INFINITY, typename Integrand::Scalar b=INFINITY, <a class="el" href="structTMBad_1_1control.html">control</a> c=<a class="el" href="structTMBad_1_1control.html">control</a>())</td></tr>
<tr class="memdesc:ac1c73a21ac1632b2dfaff8a3e0aa405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate function over finite or infinite interval.  <a href="#ac1c73a21ac1632b2dfaff8a3e0aa405a">More...</a><br /></td></tr>
<tr class="separator:ac1c73a21ac1632b2dfaff8a3e0aa405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00aca64104fb2a72dcf504491f883cd"><td class="memTemplParams" colspan="2"><a id="ad00aca64104fb2a72dcf504491f883cd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad00aca64104fb2a72dcf504491f883cd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ad00aca64104fb2a72dcf504491f883cd">invperm</a> (const std::vector&lt; T &gt; &amp;perm)</td></tr>
<tr class="memdesc:ad00aca64104fb2a72dcf504491f883cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation. <br /></td></tr>
<tr class="separator:ad00aca64104fb2a72dcf504491f883cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adc1233300ab60b78c4e365565e0839"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a7adc1233300ab60b78c4e365565e0839"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a7adc1233300ab60b78c4e365565e0839">isContiguous</a> (V &amp;x)</td></tr>
<tr class="memdesc:a7adc1233300ab60b78c4e365565e0839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this ad vector available as a contiguous block on the tape?  <a href="#a7adc1233300ab60b78c4e365565e0839">More...</a><br /></td></tr>
<tr class="separator:a7adc1233300ab60b78c4e365565e0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e2b8e4b518e0518593cc18e0c85bb0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0e2b8e4b518e0518593cc18e0c85bb0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ac0e2b8e4b518e0518593cc18e0c85bb0">lmatch</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ac0e2b8e4b518e0518593cc18e0c85bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match x vector in y vector.  <a href="#ac0e2b8e4b518e0518593cc18e0c85bb0">More...</a><br /></td></tr>
<tr class="separator:ac0e2b8e4b518e0518593cc18e0c85bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ae670bec3cb65efe603575738c6b36"><td class="memTemplParams" colspan="2">template&lt;class T , class I &gt; </td></tr>
<tr class="memitem:a77ae670bec3cb65efe603575738c6b36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a77ae670bec3cb65efe603575738c6b36">make_space_inplace</a> (std::vector&lt; T &gt; &amp;x, std::vector&lt; I &gt; &amp;i, T space=T(0))</td></tr>
<tr class="memdesc:a77ae670bec3cb65efe603575738c6b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make space for new elements in an existing vector.  <a href="#a77ae670bec3cb65efe603575738c6b36">More...</a><br /></td></tr>
<tr class="separator:a77ae670bec3cb65efe603575738c6b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce30625513d5dd19ff0fd3d81d68b4f"><td class="memTemplParams" colspan="2"><a id="a8ce30625513d5dd19ff0fd3d81d68b4f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ce30625513d5dd19ff0fd3d81d68b4f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a8ce30625513d5dd19ff0fd3d81d68b4f">match</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a8ce30625513d5dd19ff0fd3d81d68b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match x vector in y vector. <br /></td></tr>
<tr class="separator:a8ce30625513d5dd19ff0fd3d81d68b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e973230179682d81b9f06c823030915"><td class="memItemLeft" align="right" valign="top"><a id="a9e973230179682d81b9f06c823030915"></a>
vmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a9e973230179682d81b9f06c823030915">matmul</a> (const vmatrix &amp;x, const vmatrix &amp;y)</td></tr>
<tr class="memdesc:a9e973230179682d81b9f06c823030915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices of ad variables. <br /></td></tr>
<tr class="separator:a9e973230179682d81b9f06c823030915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae632849ca0d53ae5d7e4ae2a42492c25"><td class="memItemLeft" align="right" valign="top"><a id="ae632849ca0d53ae5d7e4ae2a42492c25"></a>
dmatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ae632849ca0d53ae5d7e4ae2a42492c25">matmul</a> (const dmatrix &amp;x, const dmatrix &amp;y)</td></tr>
<tr class="memdesc:ae632849ca0d53ae5d7e4ae2a42492c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices of scalar types. <br /></td></tr>
<tr class="separator:ae632849ca0d53ae5d7e4ae2a42492c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e83f54802c7f23f4f8b763e6930a5a"><td class="memTemplParams" colspan="2">template&lt;bool XT, bool YT, bool ZT, bool UP&gt; </td></tr>
<tr class="memitem:a95e83f54802c7f23f4f8b763e6930a5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a95e83f54802c7f23f4f8b763e6930a5a">matmul</a> (Map&lt; const dmatrix &gt; x, Map&lt; const dmatrix &gt; y, Map&lt; dmatrix &gt; z)</td></tr>
<tr class="separator:a95e83f54802c7f23f4f8b763e6930a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0cef3ccb08fc4b9a36d893beed3eff"><td class="memTemplParams" colspan="2">template&lt;class Integrand &gt; </td></tr>
<tr class="memitem:a1f0cef3ccb08fc4b9a36d893beed3eff"><td class="memTemplItemLeft" align="right" valign="top">mvIntegral0&lt; Integrand &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a1f0cef3ccb08fc4b9a36d893beed3eff">mvIntegrate</a> (Integrand &amp;f, <a class="el" href="structTMBad_1_1control.html">control</a> c=<a class="el" href="structTMBad_1_1control.html">control</a>())</td></tr>
<tr class="memdesc:a1f0cef3ccb08fc4b9a36d893beed3eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate integration.  <a href="#a1f0cef3ccb08fc4b9a36d893beed3eff">More...</a><br /></td></tr>
<tr class="separator:a1f0cef3ccb08fc4b9a36d893beed3eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a26d6f76a4a5ddb333569ff7485d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a93a26d6f76a4a5ddb333569ff7485d41">operator&lt;</a> (const <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &amp;x, const <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &amp;y)</td></tr>
<tr class="memdesc:a93a26d6f76a4a5ddb333569ff7485d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow / disallow comparison operators for <code>ad_aug</code>  <a href="#a93a26d6f76a4a5ddb333569ff7485d41">More...</a><br /></td></tr>
<tr class="separator:a93a26d6f76a4a5ddb333569ff7485d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f24adb336b948a33c5e945c14c42a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af80f24adb336b948a33c5e945c14c42a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#af80f24adb336b948a33c5e945c14c42a">order</a> (std::vector&lt; T &gt; x)</td></tr>
<tr class="memdesc:af80f24adb336b948a33c5e945c14c42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get permutation that sorts a vector.  <a href="#af80f24adb336b948a33c5e945c14c42a">More...</a><br /></td></tr>
<tr class="separator:af80f24adb336b948a33c5e945c14c42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d3d7acc2d3a02068309892f38d1b83"><td class="memItemLeft" align="right" valign="top"><a id="ac0d3d7acc2d3a02068309892f38d1b83"></a>
<a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ac0d3d7acc2d3a02068309892f38d1b83">pack</a> (const <a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a> &amp;x)</td></tr>
<tr class="memdesc:ac0d3d7acc2d3a02068309892f38d1b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack consecutive values on the tape. <br /></td></tr>
<tr class="separator:ac0d3d7acc2d3a02068309892f38d1b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bc1b8c42b0b04c39a847649707f86c"><td class="memItemLeft" align="right" valign="top"><a id="ad2bc1b8c42b0b04c39a847649707f86c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ad2bc1b8c42b0b04c39a847649707f86c">prod_int</a> (const std::vector&lt; size_t &gt; &amp;x)</td></tr>
<tr class="memdesc:ad2bc1b8c42b0b04c39a847649707f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer product function. <br /></td></tr>
<tr class="separator:ad2bc1b8c42b0b04c39a847649707f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1eaffa26abd798259f48bd225838090"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#af1eaffa26abd798259f48bd225838090">remap_identical_sub_expressions</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, std::vector&lt; Index &gt; inv_remap)</td></tr>
<tr class="memdesc:af1eaffa26abd798259f48bd225838090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap identical sub-expressions.  <a href="#af1eaffa26abd798259f48bd225838090">More...</a><br /></td></tr>
<tr class="separator:af1eaffa26abd798259f48bd225838090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f93ff241852d703fec8ca9c6e32a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">reorder_depth_first</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob)</td></tr>
<tr class="memdesc:a26f93ff241852d703fec8ca9c6e32a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first reordering of computational graph.  <a href="#a26f93ff241852d703fec8ca9c6e32a76">More...</a><br /></td></tr>
<tr class="separator:a26f93ff241852d703fec8ca9c6e32a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59304fbd753dbe20f62eb5c83ab1bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ae59304fbd753dbe20f62eb5c83ab1bfe">reorder_graph</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, std::vector&lt; Index &gt; inv_idx)</td></tr>
<tr class="memdesc:ae59304fbd753dbe20f62eb5c83ab1bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder computational graph such that selected independent variables come last.  <a href="#ae59304fbd753dbe20f62eb5c83ab1bfe">More...</a><br /></td></tr>
<tr class="separator:ae59304fbd753dbe20f62eb5c83ab1bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b45e31a4e1f8a7839d2540965259543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a1b45e31a4e1f8a7839d2540965259543">reorder_sub_expressions</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob)</td></tr>
<tr class="memdesc:a1b45e31a4e1f8a7839d2540965259543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-order computational graph to make it more compressible.  <a href="#a1b45e31a4e1f8a7839d2540965259543">More...</a><br /></td></tr>
<tr class="separator:a1b45e31a4e1f8a7839d2540965259543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadfc2a73d19ae22613af3cd3ed203f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#aeadfc2a73d19ae22613af3cd3ed203f6">reorder_temporaries</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob)</td></tr>
<tr class="memdesc:aeadfc2a73d19ae22613af3cd3ed203f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-order computational graph to make it more compressible.  <a href="#aeadfc2a73d19ae22613af3cd3ed203f6">More...</a><br /></td></tr>
<tr class="separator:aeadfc2a73d19ae22613af3cd3ed203f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044720b04dcd5e9104166ec491c83719"><td class="memItemLeft" align="right" valign="top"><a id="a044720b04dcd5e9104166ec491c83719"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a044720b04dcd5e9104166ec491c83719">reverse_boundary</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, const std::vector&lt; bool &gt; &amp;vars)</td></tr>
<tr class="memdesc:a044720b04dcd5e9104166ec491c83719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find boundary without using the graph. <br /></td></tr>
<tr class="separator:a044720b04dcd5e9104166ec491c83719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d8df92c0a05d0d448e1eae4a841cd1"><td class="memTemplParams" colspan="2"><a id="a38d8df92c0a05d0d448e1eae4a841cd1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a38d8df92c0a05d0d448e1eae4a841cd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a38d8df92c0a05d0d448e1eae4a841cd1">sort_inplace</a> (std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a38d8df92c0a05d0d448e1eae4a841cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility: sort inplace. <br /></td></tr>
<tr class="separator:a38d8df92c0a05d0d448e1eae4a841cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b8a480a2ea6ffca01aec59882b2d57"><td class="memTemplParams" colspan="2"><a id="a60b8a480a2ea6ffca01aec59882b2d57"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a60b8a480a2ea6ffca01aec59882b2d57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a60b8a480a2ea6ffca01aec59882b2d57">sort_unique_inplace</a> (std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a60b8a480a2ea6ffca01aec59882b2d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility: sort unique inplace. <br /></td></tr>
<tr class="separator:a60b8a480a2ea6ffca01aec59882b2d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f273488d2199251bb0ffd0bc51e770c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structTMBad_1_1period.html">period</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a7f273488d2199251bb0ffd0bc51e770c">split_period</a> (<a class="el" href="structTMBad_1_1global.html">global</a> *glob, <a class="el" href="structTMBad_1_1period.html">period</a> p, size_t max_period_size)</td></tr>
<tr class="memdesc:a7f273488d2199251bb0ffd0bc51e770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="#a7f273488d2199251bb0ffd0bc51e770c">More...</a><br /></td></tr>
<tr class="separator:a7f273488d2199251bb0ffd0bc51e770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15d841b8532f7292b15482ecf95f7f"><td class="memTemplParams" colspan="2"><a id="a0f15d841b8532f7292b15482ecf95f7f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0f15d841b8532f7292b15482ecf95f7f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a0f15d841b8532f7292b15482ecf95f7f">subset</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; bool &gt; &amp;y)</td></tr>
<tr class="memdesc:a0f15d841b8532f7292b15482ecf95f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subset by boolean mask. <br /></td></tr>
<tr class="separator:a0f15d841b8532f7292b15482ecf95f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680370b2d84fcf15bcf5dd158cf99684"><td class="memTemplParams" colspan="2"><a id="a680370b2d84fcf15bcf5dd158cf99684"></a>
template&lt;class T , class I &gt; </td></tr>
<tr class="memitem:a680370b2d84fcf15bcf5dd158cf99684"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a680370b2d84fcf15bcf5dd158cf99684">subset</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; I &gt; &amp;ind)</td></tr>
<tr class="memdesc:a680370b2d84fcf15bcf5dd158cf99684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subset by index vector. <br /></td></tr>
<tr class="separator:a680370b2d84fcf15bcf5dd158cf99684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10a11cbcba1ba6abef860177a21bd59"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ac10a11cbcba1ba6abef860177a21bd59">substitute</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, const std::vector&lt; Index &gt; &amp;seq, bool inv_tags=true, bool dep_tags=true)</td></tr>
<tr class="memdesc:ac10a11cbcba1ba6abef860177a21bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">substitute node index sequence by independent variables  <a href="#ac10a11cbcba1ba6abef860177a21bd59">More...</a><br /></td></tr>
<tr class="separator:ac10a11cbcba1ba6abef860177a21bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a789d6a042c96e48fedfa05f868f6a"><td class="memItemLeft" align="right" valign="top"><a id="a61a789d6a042c96e48fedfa05f868f6a"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a61a789d6a042c96e48fedfa05f868f6a">substitute</a> (<a class="el" href="structTMBad_1_1global.html">global</a> &amp;glob, const char *name, bool inv_tags=true, bool dep_tags=true)</td></tr>
<tr class="memdesc:a61a789d6a042c96e48fedfa05f868f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">substitute by op_name <br /></td></tr>
<tr class="separator:a61a789d6a042c96e48fedfa05f868f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae203d10f67f01e5bac8010db35deb1e7"><td class="memTemplParams" colspan="2"><a id="ae203d10f67f01e5bac8010db35deb1e7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae203d10f67f01e5bac8010db35deb1e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ae203d10f67f01e5bac8010db35deb1e7">unpack</a> (const std::vector&lt; T &gt; &amp;x, Index j)</td></tr>
<tr class="memdesc:ae203d10f67f01e5bac8010db35deb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack consecutive values on the tape. <br /></td></tr>
<tr class="separator:ae203d10f67f01e5bac8010db35deb1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25f833b8db07b58fc2b8cca25f6ca7"><td class="memItemLeft" align="right" valign="top"><a id="acc25f833b8db07b58fc2b8cca25f6ca7"></a>
<a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#acc25f833b8db07b58fc2b8cca25f6ca7">unpack</a> (const <a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a> &amp;x)</td></tr>
<tr class="memdesc:acc25f833b8db07b58fc2b8cca25f6ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack consecutive values on the tape. <br /></td></tr>
<tr class="separator:acc25f833b8db07b58fc2b8cca25f6ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f11020200051df812c0540a9cf7d02"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0f11020200051df812c0540a9cf7d02"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#ae0f11020200051df812c0540a9cf7d02">value</a> (T x)</td></tr>
<tr class="memdesc:ae0f11020200051df812c0540a9cf7d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace with utility functions for adaptive numerical integration.  <a href="#ae0f11020200051df812c0540a9cf7d02">More...</a><br /></td></tr>
<tr class="separator:ae0f11020200051df812c0540a9cf7d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a16b1556ba907455118154cf0f694bd"><td class="memTemplParams" colspan="2"><a id="a2a16b1556ba907455118154cf0f694bd"></a>
template&lt;class I &gt; </td></tr>
<tr class="memitem:a2a16b1556ba907455118154cf0f694bd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTMBad.html#a2a16b1556ba907455118154cf0f694bd">which</a> (const std::vector&lt; bool &gt; &amp;x)</td></tr>
<tr class="memdesc:a2a16b1556ba907455118154cf0f694bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert logical vector to index vector. <br /></td></tr>
<tr class="separator:a2a16b1556ba907455118154cf0f694bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Automatic differentiation library designed for TMB. </p>
<p>See <code><a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">TMBad::ADFun</a></code>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab170ef212115e6d82d5df72afc3d6342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170ef212115e6d82d5df72afc3d6342">&sect;&nbsp;</a></span>accumulation_tree_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1global.html">global</a> TMBad::accumulation_tree_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a>&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sum_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a computational graph by it's accumulation tree. </p>
<p>This routine transforms a function object with univariate output into a function object with multiple outputs. Each new output represents a term of the original function, i.e. by summing all the terms one can recover the original function. </p><dl class="section note"><dt>Note</dt><dd>FIXME: Handle the case Range() &gt; 1. Select which component ? </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l03613">3613</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#ad0192b09b65b16f46e0a69a35f34f451">TMBad::ADFun&lt;&gt;::marginal_gk()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a3aab8cd00fa96e30755e2b7488df13b9">TMBad::ADFun&lt;&gt;::marginal_sr()</a>, and <a class="el" href="namespaceTMBad.html#af80f24adb336b948a33c5e945c14c42a">order()</a>.</p>

</div>
</div>
<a id="a8942995be599665e0914b3367c75e3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8942995be599665e0914b3367c75e3cd">&sect;&nbsp;</a></span>ADFun_retaping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor , class Test  = ParametersChanged&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1ADFun.html">ADFun</a> TMBad::ADFun_retaping </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Test&#160;</td>
          <td class="paramname"><em>test</em> = <code>Test()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">ADFun</a> that automatically retapes. </p>
<p>By default, retaping takes place whenever the parameter vector changes compared to previous evaluation. However, this can be controlled in more detail by passing a custom tester object - see the prototype <code><a class="el" href="structTMBad_1_1ParametersChanged.html" title="Default tester for retaping_derivative_table. ">ParametersChanged</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>Functor to be taped </td></tr>
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Test</td><td>Class to test if parameters have changed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8hpp_source.html#l01165">1165</a> of file <a class="el" href="TMBad_8hpp_source.html">TMBad.hpp</a>.</p>

<p>Referenced by <a class="el" href="structsparse__matrix__exponential_1_1expm__series.html#af0859a73859eab43475362e478b628da">sparse_matrix_exponential::expm_series&lt; T &gt;::operator()()</a>.</p>

</div>
</div>
<a id="a378f5a84861c70994f30a12b9e2b7f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378f5a84861c70994f30a12b9e2b7f47">&sect;&nbsp;</a></span>ADFun_retaping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor , class Test &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1ADFun__packed.html">ADFun_packed</a> TMBad::ADFun_retaping </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structTMBad_1_1global_1_1ad__segment.html">ad_segment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Test&#160;</td>
          <td class="paramname"><em>test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="structTMBad_1_1ADFun.html" title="Automatic differentiation function object. ">ADFun</a> that automatically retapes. </p>
<p>By default, retaping takes place whenever the parameter vector changes compared to previous evaluation. However, this can be controlled in more detail by passing a custom tester object - see the prototype <code><a class="el" href="structTMBad_1_1ParametersChanged.html" title="Default tester for retaping_derivative_table. ">ParametersChanged</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>Functor to be taped </td></tr>
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Test</td><td>Class to test if parameters have changed</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object is <code><a class="el" href="structTMBad_1_1ADFun__packed.html" title="Container of ADFun object with packed input and output. ">ADFun_packed</a></code>, i.e. it has <em>packed</em> inputs <b>and</b> outputs. Such packed I/O can compactly represent e.g. matrices, vectors or other large objects with a consequtive memory layout. </p>

<p>Definition at line <a class="el" href="TMBad_8hpp_source.html#l01194">1194</a> of file <a class="el" href="TMBad_8hpp_source.html">TMBad.hpp</a>.</p>

</div>
</div>
<a id="a9da8f10d11a2ebeb90e146372c438714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da8f10d11a2ebeb90e146372c438714">&sect;&nbsp;</a></span>aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a multivariate output function by summing its range components. </p>
<p>On input the tape represents a function f:R^m-&gt;R^n. On output the tape represents a function f:R^m-&gt;R. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glob</td><td>Tape which is modified by this function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l03653">3653</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1autopar.html#ac5cb220e781af8a02e6a43ea0fd7a3b6">TMBad::autopar::extract()</a>, <a class="el" href="structTMBad_1_1ADFun.html#ad0192b09b65b16f46e0a69a35f34f451">TMBad::ADFun&lt;&gt;::marginal_gk()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a3aab8cd00fa96e30755e2b7488df13b9">TMBad::ADFun&lt;&gt;::marginal_sr()</a>, and <a class="el" href="namespaceTMBad.html#af80f24adb336b948a33c5e945c14c42a">order()</a>.</p>

</div>
</div>
<a id="a7d5dbfbcb2e6c7ca956e9032175ffc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5dbfbcb2e6c7ca956e9032175ffc69">&sect;&nbsp;</a></span>all_allow_remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TMBad::all_allow_remap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if all operators in the stack allow input remapping. </p>
<p>I.e. test if <code><a class="el" href="structTMBad_1_1op__info.html#af522ad98410a04a8fff4be06e85be3a7a93b52f3b482f43a7ec7b7db4cffc2066" title="Is it safe to remap the inputs of this operator? ">op_info.allow_remap</a> = true</code> for all operators. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l04291">4291</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ae59304fbd753dbe20f62eb5c83ab1bfe">reorder_graph()</a>.</p>

</div>
</div>
<a id="a02c930c5983988be2a3c57322b23ebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c930c5983988be2a3c57322b23ebde">&sect;&nbsp;</a></span>contiguousBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTMBad_1_1global_1_1ad__segment.html">global::ad_segment</a> TMBad::contiguousBlock </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a contiguous block on the tape. </p>
<ol type="1">
<li>Check if <code>x</code> already is on the tape and satisfies the storage requirement.</li>
<li>If <b>no</b> invoke a deep copy of <code>x</code> to the tape <b>and</b> <em>update</em> <code>x</code> with the new tape addresses.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>x</code> as a contiguous block on the tape.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The update step is critical as it ensures that a given matrix can be used several times without invoking a deep copy more than once. </dd></dl>

<p>Definition at line <a class="el" href="ad__blas_8hpp_source.html#l00023">23</a> of file <a class="el" href="ad__blas_8hpp_source.html">ad_blas.hpp</a>.</p>

</div>
</div>
<a id="adfc2a635fea773aff598ccbeaaacd074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc2a635fea773aff598ccbeaaacd074">&sect;&nbsp;</a></span>forceContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::forceContiguous </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make contiguous ad vector. </p>
<p>Template type 'V::value_type' can be</p><ul>
<li>ad_plain</li>
<li>ad_aug</li>
<li>ad_adapt </li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l03083">3083</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1sequential__reduction.html#ab7f1dcb61e1e5fca346d0c1059b9d8da">TMBad::sequential_reduction::tabulate()</a>.</p>

</div>
</div>
<a id="af5a6038cd6873a41e51cd770137727bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a6038cd6873a41e51cd770137727bf">&sect;&nbsp;</a></span>get_accumulation_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; TMBad::get_accumulation_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node indices of the accumulation tree or its boundary. </p>
<p>The tree is defined as the maximal <b>topologically closed</b> sub graph T, containing only linear operators. In other words, the nodes in the tree are not allowed to produce variables that are inputs to any non linear operators. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l03550">3550</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">accumulation_tree_split()</a>, and <a class="el" href="namespaceTMBad.html#af80f24adb336b948a33c5e945c14c42a">order()</a>.</p>

</div>
</div>
<a id="a0907fd10ecf16de43870745c81f7d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0907fd10ecf16de43870745c81f7d72b">&sect;&nbsp;</a></span>getContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V TMBad::getContiguous </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contiguous (deep) copy of this vector. </p>
<p>Template type 'V::value_type' can be</p><ul>
<li>ad_plain</li>
<li>ad_aug</li>
<li>ad_adapt </li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l03071">3071</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#adfc2a635fea773aff598ccbeaaacd074">forceContiguous()</a>.</p>

</div>
</div>
<a id="ac1c73a21ac1632b2dfaff8a3e0aa405a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c73a21ac1632b2dfaff8a3e0aa405a">&sect;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integrand &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integrand::Scalar TMBad::integrate </td>
          <td>(</td>
          <td class="paramtype">Integrand&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Integrand::Scalar&#160;</td>
          <td class="paramname"><em>a</em> = <code>-INFINITY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Integrand::Scalar&#160;</td>
          <td class="paramname"><em>b</em> = <code>INFINITY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1control.html">control</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structTMBad_1_1control.html">control</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate function over finite or infinite interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Univariate integrand (functor) </td></tr>
    <tr><td class="paramname">a</td><td>Lower integration limit. Default is negative infinity. </td></tr>
    <tr><td class="paramname">a</td><td>Upper integration limit. Default is positive infinity. </td></tr>
    <tr><td class="paramname">c</td><td>Optional control parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Float&gt;</div><div class="line"><span class="keyword">struct </span>Gauss_t {</div><div class="line">  <span class="keyword">typedef</span> Float Scalar;</div><div class="line">  Float a;  <span class="comment">// Parameter</span></div><div class="line">  <span class="comment">// Evaluate integrand</span></div><div class="line">  Float operator(Float x) () {</div><div class="line">    Float ans = exp(- a*x*x);</div><div class="line">    <span class="keywordflow">return</span> ans;</div><div class="line">  }</div><div class="line">  <span class="comment">// Integrate wrt x</span></div><div class="line">  Float my_integrate() {</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacegauss__kronrod.html#ad2a3bebe64e675f09612aa6211ef1998">gauss_kronrod::integrate</a>;</div><div class="line">    Float ans = <a class="code" href="namespaceTMBad.html#ac1c73a21ac1632b2dfaff8a3e0aa405a">integrate</a>(*<span class="keyword">this</span>);</div><div class="line">    <span class="keywordflow">return</span> ans;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="TMBad_2integrate_8hpp_source.html#l01111">1111</a> of file <a class="el" href="TMBad_2integrate_8hpp_source.html">TMBad/integrate.hpp</a>.</p>

</div>
</div>
<a id="a7adc1233300ab60b78c4e365565e0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adc1233300ab60b78c4e365565e0839">&sect;&nbsp;</a></span>isContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TMBad::isContiguous </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this ad vector available as a contiguous block on the tape? </p>
<p>Template type 'V::value_type' can be</p><ul>
<li>ad_plain</li>
<li>ad_aug</li>
<li>ad_adapt </li>
</ul>

<p>Definition at line <a class="el" href="global_8hpp_source.html#l03045">3045</a> of file <a class="el" href="global_8hpp_source.html">global.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#adfc2a635fea773aff598ccbeaaacd074">forceContiguous()</a>.</p>

</div>
</div>
<a id="ac0e2b8e4b518e0518593cc18e0c85bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e2b8e4b518e0518593cc18e0c85bb0">&sect;&nbsp;</a></span>lmatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; TMBad::lmatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match x vector in y vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Logical vector of the same length as x </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intended for small vectors only </dd></dl>

<p>Definition at line <a class="el" href="graph__transform_8hpp_source.html#l00019">19</a> of file <a class="el" href="graph__transform_8hpp_source.html">graph_transform.hpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1clique.html#a229ca475b3c7a7b16845506de762ce46">TMBad::clique::get_stride()</a>, and <a class="el" href="namespaceTMBad.html#a8ce30625513d5dd19ff0fd3d81d68b4f">match()</a>.</p>

</div>
</div>
<a id="a77ae670bec3cb65efe603575738c6b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ae670bec3cb65efe603575738c6b36">&sect;&nbsp;</a></span>make_space_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::make_space_inplace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>space</em> = <code>T(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make space for new elements in an existing vector. </p>
<p>Resize and move elements of a vector to make space for index <code>i</code> new members. Vector <code>x</code> and index vector <code>i</code> are modified such that</p>
<ul>
<li>Index vector points at the same elements as before: <code>x_new[i_new] == x_old[i_old]</code> except that <code>i_new</code> is sorted while <code>i_old</code> might not be.</li>
<li>Undefined elements are at positions <code>i-1</code></li>
<li>Removing the undefined elements you get the old vector </li>
</ul>

<p>Definition at line <a class="el" href="graph__transform_8hpp_source.html#l00068">68</a> of file <a class="el" href="graph__transform_8hpp_source.html">graph_transform.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ac10a11cbcba1ba6abef860177a21bd59">substitute()</a>.</p>

</div>
</div>
<a id="a95e83f54802c7f23f4f8b763e6930a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e83f54802c7f23f4f8b763e6930a5a">&sect;&nbsp;</a></span>matmul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool XT, bool YT, bool ZT, bool UP&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::matmul </td>
          <td>(</td>
          <td class="paramtype">Map&lt; const dmatrix &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; const dmatrix &gt;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; dmatrix &gt;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand all 16 combinations </p>

<p>Definition at line <a class="el" href="ad__blas_8hpp_source.html#l00092">92</a> of file <a class="el" href="ad__blas_8hpp_source.html">ad_blas.hpp</a>.</p>

</div>
</div>
<a id="a1f0cef3ccb08fc4b9a36d893beed3eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0cef3ccb08fc4b9a36d893beed3eff">&sect;&nbsp;</a></span>mvIntegrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integrand &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mvIntegral0&lt;Integrand&gt; TMBad::mvIntegrate </td>
          <td>(</td>
          <td class="paramtype">Integrand &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1control.html">control</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structTMBad_1_1control.html">control</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multivariate integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Multivariate integrand (functor) </td></tr>
    <tr><td class="paramname">c</td><td>Optional control parameters</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Float&gt;</div><div class="line"><span class="keyword">struct </span>Gauss2D_t {</div><div class="line">  <span class="keyword">typedef</span> Float Scalar;</div><div class="line">  Float a, b;  <span class="comment">// Parameters</span></div><div class="line">  Float x, y;  <span class="comment">// Integration variables</span></div><div class="line">  <span class="comment">// Evaluate integrand (u1,u2)</span></div><div class="line">  Float operator() () {</div><div class="line">    Float ans = exp(- a*x*x - b*y*y);</div><div class="line">    <span class="keywordflow">return</span> ans;</div><div class="line">  }</div><div class="line">  <span class="comment">// Integrate wrt (x,y)</span></div><div class="line">  Float my_integrate() {</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacegauss__kronrod.html#a4d70d01b00bd9d461e54f17766187a3c">gauss_kronrod::mvIntegrate</a>;</div><div class="line">    Float ans = <a class="code" href="namespaceTMBad.html#a1f0cef3ccb08fc4b9a36d893beed3eff">mvIntegrate</a>(*this).</div><div class="line">      wrt(x, -INFINITY, INFINITY).</div><div class="line">      wrt(y, -INFINITY, INFINITY) ();</div><div class="line">    <span class="keywordflow">return</span> ans;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="TMBad_2integrate_8hpp_source.html#l01199">1199</a> of file <a class="el" href="TMBad_2integrate_8hpp_source.html">TMBad/integrate.hpp</a>.</p>

</div>
</div>
<a id="a93a26d6f76a4a5ddb333569ff7485d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a26d6f76a4a5ddb333569ff7485d41">&sect;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TMBad::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTMBad_1_1global_1_1ad__aug.html">ad_aug</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow / disallow comparison operators for <code>ad_aug</code> </p>
<p>It is recommended to disable comparison for the non-retaping type <code>ad_aug</code>, i.e. not including this file! </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l04492">4492</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="af80f24adb336b948a33c5e945c14c42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80f24adb336b948a33c5e945c14c42a">&sect;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; TMBad::order </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get permutation that sorts a vector. </p>
<p>If <code>x</code> equals</p>
<p><code>{5, 4, 3, 5, 4, 3, 5, 2, 1}</code></p>
<p>Then <code>order(x)</code> is</p>
<p><code>{8, 7, 2, 5, 1, 4, 0, 3, 6}</code></p>
<dl class="section note"><dt>Note</dt><dd>Order of duplicates within groups is preserved </dd></dl>

<p>Definition at line <a class="el" href="graph__transform_8hpp_source.html#l00117">117</a> of file <a class="el" href="graph__transform_8hpp_source.html">graph_transform.hpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1autopar.html#aabf9829b1406e5bdfa6066da9c28cb2d">TMBad::autopar::max_tree_depth()</a>, and <a class="el" href="structTMBad_1_1ADFun.html#ac9925689705ff5761502b2675fe78934">TMBad::ADFun&lt;&gt;::set_inv_positions()</a>.</p>

</div>
</div>
<a id="af1eaffa26abd798259f48bd225838090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1eaffa26abd798259f48bd225838090">&sect;&nbsp;</a></span>remap_identical_sub_expressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; TMBad::remap_identical_sub_expressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt;&#160;</td>
          <td class="paramname"><em>inv_remap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap identical sub-expressions. </p>
<h3>Description</h3>
<p>Recall that all variables are stored sequentially on the tape and that each variable can be thought of as an 'expression'. The purpuse of the present function is to find out for any given variable whether it has already been calculated and, if so, find its first occurance. Finally, having constructed such a variable remapping table, we apply the remapping to all operator <em>inputs</em>, and return.</p>
<p>This routine is thus only useful when followed by a call to the method <code><a class="el" href="structTMBad_1_1global.html#aec6a949ba45e07c3011c0452693fc054" title="Very simple tape optimizer. ">global::eliminate</a></code>, which will remove all redundant variables.</p>
<h3>Algorithm</h3>
<p>The algorithm essentially consists of two forward passes:</p>
<ol type="1">
<li><b>Hash step</b> Calculate a table of <em>likely</em> valid remappings using <code><a class="el" href="structTMBad_1_1global.html#a8c705966ba5c49c15bc2613ced3768aa" title="Calculate hash codes of each dependent variable using a single forward sweep. ">global::hash_sweep</a></code> and <code><a class="el" href="namespaceradix.html#a3ca128f4115a090cd4b2a159c638fdc3" title="For each element of a vector find the index of its first occurance from the left. ...">radix::first_occurance</a></code>. We call the resulting vector 'remap'. It satisfies <code>remap[i] &lt;= i</code> with equality signifying that the variable <code>i</code> must be kept as is (which is always valid).</li>
<li><b>Proof step</b> Assume by induction that <code>remap[j]</code> is valid for all j strictly less than i. We must decide if <code>remap[i]</code> is valid, that is if the expressions <code>remap[i]</code> and <code>i</code> are identical. The two expressions are identical if they are result of the same operator <em>and</em> if their inputs are identical expressions. Because these inputs have index smaller than <code>i</code> we know that <code>remap</code> is valid for them. In other words we simply check that <code>remap[inputs(remap[i])]</code> is the same as <code>remap[inputs(i)]</code>. If this is the case we have proved that the expressions are equal and can accept the remapping. Otherwise we reject the remapping by setting <code>remap[i]=i</code>. In any case <code>remap[i]</code> now contains a valid remapping which completes the induction step.</li>
</ol>
<h3>Applying the remap</h3>
<p>To summarize the above algorithm, it gives as output a vector <code>remap</code> such that expressions <code>i</code> and <code>remap[i]</code> are identical. We can thus apply the remap to all operator inputs and get an equivalent computational graph.</p>
<p>However, special attention must be payed to operators with pointer inputs because they assume a contiguous memory layout. If an operator assumes a contiguous memory layout of the variables <code>a:b</code> we must require that the remapped variables <code>remap[a:b]</code> are also contiguous. This is done as a post rejection step by setting <code>remap[a:b] := a:b</code> for invalid remappings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glob</td><td>Function object to be modified </td></tr>
    <tr><td class="paramname">all_allow_remap</td><td>Skip extra check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l04303">4303</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

</div>
</div>
<a id="a26f93ff241852d703fec8ca9c6e32a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f93ff241852d703fec8ca9c6e32a76">&sect;&nbsp;</a></span>reorder_depth_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::reorder_depth_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth-first reordering of computational graph. </p>
<p>Application: Register optimization for GPU </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00595">595</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1periodic.html#a712569133a91fd9cce7ca044ef3b0827">TMBad::periodic&lt; T &gt;::find_best_period()</a>, and <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">reorder_depth_first()</a>.</p>

</div>
</div>
<a id="ae59304fbd753dbe20f62eb5c83ab1bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59304fbd753dbe20f62eb5c83ab1bfe">&sect;&nbsp;</a></span>reorder_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::reorder_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt;&#160;</td>
          <td class="paramname"><em>inv_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder computational graph such that selected independent variables come last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inv_idx</td><td>Sorted vector of independent variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Nothing is done if <b>any operators with pointer inputs are detected on the tape</b>. (FIXME: Not optimal) </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l04455">4455</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1ADFun.html#a91d9e0e63497857f84456660c8188b96">TMBad::ADFun&lt;&gt;::reorder()</a>.</p>

</div>
</div>
<a id="a1b45e31a4e1f8a7839d2540965259543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b45e31a4e1f8a7839d2540965259543">&sect;&nbsp;</a></span>reorder_sub_expressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::reorder_sub_expressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-order computational graph to make it more compressible. </p>
<p>The degree of compression offered by the periodic sequence analysis can be greatly improved by re-ordering the computational graph before the analysis. The re-ordering algorithm works as follows (see also <code>remap_identical_sub_expressions</code>).</p>
<ol type="1">
<li><b>Hash step</b> Two sub-expressions are considered 'weakly similar' if they are result of the same operator sequence without necessarily sharing any constants or independent variables. Assume we have a vector of hash codes 'h' - one for each sub-expression. Expressions with the same hash code are likely 'weakly similar'. Now <code>remap:=first_occurance(h)</code> gives a likely valid reordering of variables satisfying <code>remap[i] &lt;= i</code>.</li>
<li><b>Proof step</b> Assume by induction that <code>remap[j]</code> is valid for all j strictly less than i. Test if remap[i] is also valid (i.e. max(remap[dependencies(v2o(i))]) &lt; remap[i]). If yes keep it. If no reject it be setting remap[i]=i (which is always valid).</li>
<li>Now <code>remap</code> provides a valid ordering of the graph using the permutation <code>radix::order(remap)</code> </li>
</ol>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00537">537</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1periodic.html#a712569133a91fd9cce7ca044ef3b0827">TMBad::periodic&lt; T &gt;::find_best_period()</a>, and <a class="el" href="namespaceTMBad.html#a1b45e31a4e1f8a7839d2540965259543">reorder_sub_expressions()</a>.</p>

</div>
</div>
<a id="aeadfc2a73d19ae22613af3cd3ed203f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadfc2a73d19ae22613af3cd3ed203f6">&sect;&nbsp;</a></span>reorder_temporaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TMBad::reorder_temporaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-order computational graph to make it more compressible. </p>
<p>Potential re-ordering to be applied <b>after</b> <code>reorder_sub_expressions</code>. Pushes all temporaries forward. Here a temporary* is defined as a variable which is only used once as input to an operator. </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00567">567</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1periodic.html#a712569133a91fd9cce7ca044ef3b0827">TMBad::periodic&lt; T &gt;::find_best_period()</a>, and <a class="el" href="namespaceTMBad.html#aeadfc2a73d19ae22613af3cd3ed203f6">reorder_temporaries()</a>.</p>

</div>
</div>
<a id="a7f273488d2199251bb0ffd0bc51e770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f273488d2199251bb0ffd0bc51e770c">&sect;&nbsp;</a></span>split_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structTMBad_1_1period.html">period</a> &gt; TMBad::split_period </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> *&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1period.html">period</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_period_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper. </p>
<ul>
<li>Given a operator period, i.e. (begin, size, rep)</li>
<li>Given the full input sequence (glob.inputs) Make a split of the operator period such that the inputs are periodic as well. The split is represented as a vector of periods. Algorithm:</li>
</ul>
<ol type="1">
<li>Find matrix of input diffs</li>
<li>Row-wise, find all periods and mark the 'period boundaries', i.e. (begin, begin+size*rep) in a common boolean workspace (shared by all rows).</li>
<li>Construct the period split. Each mark signifies the beginning of a new period.</li>
</ol>
<p>FIXME: This function implementation is still a bit unclear </p>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l00190">190</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1periodic.html#a712569133a91fd9cce7ca044ef3b0827">TMBad::periodic&lt; T &gt;::find_best_period()</a>, <a class="el" href="namespaceTMBad.html#a26f93ff241852d703fec8ca9c6e32a76">reorder_depth_first()</a>, and <a class="el" href="namespaceTMBad.html#a7f273488d2199251bb0ffd0bc51e770c">split_period()</a>.</p>

</div>
</div>
<a id="ac10a11cbcba1ba6abef860177a21bd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10a11cbcba1ba6abef860177a21bd59">&sect;&nbsp;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; TMBad::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTMBad_1_1global.html">global</a> &amp;&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inv_tags</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dep_tags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>substitute node index sequence by independent variables </p>
<dl class="section note"><dt>Note</dt><dd>Currently all operators in sequence must be different from InvOp </dd></dl>

<p>Definition at line <a class="el" href="TMBad_8cpp_source.html#l03584">3584</a> of file <a class="el" href="TMBad_8cpp_source.html">TMBad.cpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceTMBad.html#ab170ef212115e6d82d5df72afc3d6342">accumulation_tree_split()</a>, <a class="el" href="structTMBad_1_1ADFun.html#a7eaf97afbbf35a63d2895b12a18391ce">TMBad::ADFun&lt;&gt;::decompose()</a>, <a class="el" href="namespaceTMBad.html#af80f24adb336b948a33c5e945c14c42a">order()</a>, and <a class="el" href="namespaceTMBad.html#a61a789d6a042c96e48fedfa05f868f6a">substitute()</a>.</p>

</div>
</div>
<a id="ae0f11020200051df812c0540a9cf7d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f11020200051df812c0540a9cf7d02">&sect;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double TMBad::value </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace with utility functions for adaptive numerical integration. </p>
<p>Interfaces to R's integrator that can be used with forward mode AD. </p>

<p>Definition at line <a class="el" href="TMBad_2integrate_8hpp_source.html#l00015">15</a> of file <a class="el" href="TMBad_2integrate_8hpp_source.html">TMBad/integrate.hpp</a>.</p>

<p>Referenced by <a class="el" href="structTMBad_1_1global.html#ad0d7d23b96392bb9f92a0799a26a874f">TMBad::global::clear_array_subgraph()</a>.</p>

</div>
</div>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
